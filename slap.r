rebol [
	; -- Core Header attributes --
	title: "SLAP | Slim Application packager"
	file: %slap.r
	version: 1.1.0
	date: 2018-09-25
	author: "Maxim Olivier-Adlhoch"
	purpose: {Automated integration, packaging and linking of application distribution.}
	web: http://www.revault.org/modules/slap.rmrk
	source-encoding: "Windows-1252"
	note: {slim Library Manager is Required to use this module.}

	; -- slim - Library Manager --
	slim-name: 'slap
	slim-version: 1.3.1
	slim-prefix: none
	slim-update: http://www.revault.org/downloads/modules/slap.r

	; -- Licensing details  --
	copyright: "Copyright © 2013 Maxim Olivier-Adlhoch"
	license-type: "Apache License v2.0"
	license: {Copyright © 2013 Maxim Olivier-Adlhoch

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at
	
		http://www.apache.org/licenses/LICENSE-2.0
	
	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.}

	;-  / history
	history: {
		v1.0.0 - 9-Sep-2013
			-license change to Apache v2
			
		v1.1.0 - 2018-09-25
			- skipped many history entries
			- updated slim-link library reference to slink.
			
	}
	;-  \ history

	;-  / documentation
	documentation: {
		Slap is not yet documented, but mainly it works by building a distribution folder 
		into which you can copy and manipulate any files.  The system includes a way to automatically
		number the distributions folders.

		All functions deal in the distribution automatically or have it as the destination.
}
	;-  \ documentation
]



;--------------------------------------
; unit testing setup
;--------------------------------------
;
; test-enter-slim 'slap
;
;--------------------------------------

slim/register [
	zipper: slim/open 'zipper none
	
	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;-     LIBS
	;
	;-----------------------------------------------------------------------------------------------------------
	slim/open/expose 'utils-files none [ 
		substitute-file   itemize-path   extension-of   
		filename-of   directory-of   prefix-of   os-copy 
		dir-tree
	] 

	linker: slim/open 'slink none
	
	
	
	
	;- GLOBALS
	;--------------------------------------
	; these are defaults, overide at will
	;--------------------------------------
	
	
	;--------------------------
	;-     root-dir:
	;
	; the root of all distributions, mainly used to check for version number.
	;
	; after you call setup-distro, it will be an absolute path.
	;--------------------------
	root-dir: %distributions/
	

	;--------------------------
	;-     distro-dir:
	;
	; the destination path of all distro operations, may be changed on the fly.
	;--------------------------
	distro-dir: none
	
	
	;--------------------------
	;-     distro-root:
	;
	; (deprecated?)
	;
	; the root of the distro generated by 'DISTRO-ROOT-SPEC
	;
	; this path is ever only changed when we use setup distro, so you can use it
	; in order to manually change 'DISTRO-DIR based on the root of the distribution.
	;--------------------------
	;distro-root: none
	
	
	;--------------------------
	;-     source-dir:
	;
	; the explicit source directory.
	; note that this path should be an absolute path after setup-distro()
	; is performed.
	;--------------------------
	source-dir: %./
	
	
	;--------------------------
	;-     distro-name:
	;
	; the general name of this distribution.
	;--------------------------
	distro-name: 'build
	
	
	;--------------------------
	;-     distro-root-spec:
	;
	; the specification of how the distro-dir is built.
	;
	; this will be used by setup in order to build the distro-dir path.
	;
	; NOTE:  DO NOT INCLUDE THE TRAILING "/" IN THE SPEC.
	;--------------------------
	distro-root-spec: [ distro-name "-r" <RELEASE> ]
	
	
	;--------------------------
	;-     distro-root-search-spec:
	;
	; it is used by the get-current-release-number() function and should be 
	;
	; synchronised with the distro-root-spec  attribute.
	;
	; by default, they are the same spec, but in some systems, we need additional
	; variables in the root-dir, and a simple match with the release number is not enough.
	;
	; if you want to add a version in the root dir, you'd add version building words 
	; within the root distro-root-spec but digit matching rules in the distro-root-search-spec instead.
	;
	; NOTE:  DO NOT INCLUDE THE TRAILING "/" IN THE SPEC.
	;--------------------------
	distro-root-search-spec: distro-root-spec
	
	
	;--------------------------
	;-     distro-label:
	;
	; the specific label of the distribution's
	; current setup.
	;
	; after setu-distro, this will be the reducec distro-root-spec
	;--------------------------
	distro-label: distro-name
	
	
	;--------------------------
	;-     distro-version:
	;
	; stores the current release version after having been scanned in get-current-release-number()
	;--------------------------
	distro-version: 0
	
	
	;--------------------------
	;-     release-number-padding:
	;
	; how many 0 padding do we need in the release number of distro-label?
	;--------------------------
	release-number-padding: 3
	
	
	;--------------------------
	;-     fix-extensions:
	;
	; when doing a recursive fix operation, only fix files with the following
	; extensions in them.
	;
	; these should only be ascii/utf8 files.
	;
	; note that this list is NOT used when FILE path are given to fix. it will always fix explicit files you tell it to.
	;--------------------------
	fix-extensions: [
		; text 
		"txt" 
		; dev
		"r" "r3" "reb" "rmrk" "doc" "c" "h" "cp" "cpp" "cs"
		; web 
		"cs" "html" "htm"  "css" "js" "php" "asp" "aspx" "j" "jsp"
	]
	
	
	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- ENCAP-ATTRIBUTES
	;
	;-----------------------------------------------------------------------------------------------------------
	encap-path: none
	encap-exe: none
	encap-includes: none
	prebol-script:  none
	pre-rebol-script: none
	encapped-exe-file: none
	encapped-script-file: none
	
	
	
	
	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- PARSE RULES
	;
	;-----------------------------------------------------------------------------------------------------------

	;--------------------------
	;-     =digits=:
	=digit=: charset "0123456789" 

	;--------------------------
	;-     =whitespace=:
	=whitespace=: charset "^- "
	
	;--------------------------
	;-     =newline=:
	=newline=: charset "^/" 
	
	;--------------------------
	;-     =text=:
	=text=: complement =newline=
	
	;--------------------------
	;-     =separator=:
	=separator=: charset "^- ^/()[]{}^""

	;--------------------------
	;-         =macro-start=:
	;
	; identifies where a preprocessor command starts in slap.  
	; change this in the call to 'PREPROCESS if it collides with your application data
	;
	; eventually, 
	;--------------------------
	=macro-start=: "<#"
	
	;--------------------------
	;-         =macro-end=:
	;
	; identifies where a preprocessor command starts in slap.  
	; change this in the call to 'PREPROCESS if it collides with your application data
	;
	; eventually, 
	;--------------------------
	=macro-end=: "#>"
	


	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- ENCAP FUNCTIONS
	;
	;-----------------------------------------------------------------------------------------------------------
	

	;--------------------------
	;-     setup-encap()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    by default we use the COMMAND VIEW encapper which has all the feature of rebol.
	;
	; tests:    
	;--------------------------
	setup-encap: func [
		sdk-dir [ file! ]
		/cmd  "use encmd.exe"
		/pro  "use enpro.exe"
		/view "use enface.exe"
		/base "use enbase.exe"
		/basis basename [word!]
		/tmp tmpscript [file!]
		/output out-name [ word! file! ] "file! is used as-is... word! may .exe appended"
		/local encapper
	][
		vin "slap/setup-encap()"
		encap-path: clean-path sdk-dir
		
		
		encapper: case [
			pro			[ 'enpro  ]
			cmd			[ 'encmd  ]
			;rebcmd		[ %rebcmd.exe  ]
			base		[ 'enbase ]
			view		[ 'enface ]
			'default	[ 'encmdview ]
		]
		
		if platform-name = 'win32 [
			encapper: to-word rejoin ["" encapper ".exe"]
		]
		
		if basis [
			out-name: basename
			tmpscript: to-file rejoin [ basename  "-preboled.r" ]
		]
		
		
		out-name: any [
			out-name
			distro-name
		]
		
		encap-exe: rejoin [ encap-path %tools/ encapper ]
		encap-includes: join encap-path %source/
		prebol-script:    rejoin [ encap-path %tools/ %prebol.r ]
		
		pre-rebol-script: rejoin [ encap-path %tools/ %prerebol.r ]
		
		encapped-script-file: any [ 
			; preboled filename given
			all [
				tmp
				any [
					all [ absolute-path? tmpscript tmpscript ]
					join distro-dir tmpscript
				]
			]
			
			; default
			to-file rejoin [ out-name  "-preboled.r" ]
		]
		
		if word? out-name [
			out-name: to-file rejoin [ out-name  ".exe" ]
		]
		encapped-exe-file:  out-name
		
		do prebol-script
		vout
	]
	

	;--------------------------
	;-         fix-exe-title()
	;--------------------------
	; purpose:  matching the encap refinements, fix the exe so rebol disapears
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    - your given string is truncated to original app's exe name.
	;           - 
	;
	; to do:    
	;
	; tests:    
	;--------------------------
	fix-exe-title: funcl [
		exe-path [file!]
		new-name [string!]
		/cmd  "use encmd.exe"
		/pro  "use enpro.exe"
		/view "use enface.exe"
		/base "use enbase.exe"
	][
		vin "fix-exe-title()"
		
		src-name: case [
			cmd  ["REBOL/Command"]
			pro  ["REBOL/Pro"]
			base ["REBOL/Base"]
			'default [ "REBOL/View" ] ; also used for encmdview
		]
		src-len: length? src-name
		new-len: length? new-name
		
		v?? src-len
		v?? new-len
		
		new-name: copy new-name
		
		case [
			src-len > new-len [
				; fill in the gap
				insert/dup tail new-name " " (src-len - new-len)
			]
			new-len > src-len [
				; truncate
				clear (at new-name src-len + 1)
			]
		]
		
		v?? src-name
		v?? new-name
		
		data: read/binary exe-path
		replace/all data src-name new-name
		write/binary exe-path data
		vout
	]

	;--------------------------
	;-     preprocess()
	;--------------------------
	; purpose:  a string-based preprocessor which doesn't obey the normal rules of REBOL syntax allowing you to
	;           be much more precise in your builds.
	;
	; inputs:   
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	preprocess: funcl [
		origin [string! binary! file!]
		/keep-header "when a rebol source is given, skip the header.  Otherwise, we don't assume its a script.   note this option is not recursive."
		/markers start [string!]  end [string!] "replace start and end markers for macros."
		/options opt-blk [block! none!] "a block of options which can be easily cascaded and mutilated in recursive processing." 
		/as filename [file!] "may include sub-paths, MUST include a filename."
	][
		vin "slap/preprocess()"
		;destination:  none
		
		=macro-start=: any [start self/=macro-start=]
		=macro-end=:   any [end   self/=macro-end=]
		
		
		if file? origin [
			pre-wd: what-dir
			origin: distro-path origin
			
			file: prefix-of origin 
			file: rejoin [file %-preprocessed.r]
			
			v?? origin
			v?? file
			
			destination: rejoin [ 
				directory-of origin 
				any [
					filename
					file 
				]
			]
			v?? destination
			
			unless filename-of destination [
				to-error "slap/preprocess() requires a filename within destination path."
			]
			
			change-dir directory-of origin
			
			origin: read origin
		]
		
		vprobe length? origin
		
		;--
		; we skip rebol headers by default
		if all [
			;---
			; this IS a rebol script
			keep-header
			not origin: extract-script origin
		][
			to-error "Unable to skip header, not a rebol script."
		]
		
		i: 0
		
		parse/all origin [
			any [
				
				[
					.macro-start:  =macro-start=
					any =whitespace= 
					
					[
						[
							[
								;------
								;-        - #INCLUDE
								;--
								; the basic include just does file substitution.
								; it doesn't detect circular refs, so be careful.
								;
								; #INCLUDE IS recursive
								[
									copy .cmd "include" 
									(vprint "slap/preprocess() Found #INCLUDE" )
									copy .refinements opt [
										any [
;											"/string"  ()   ; add outer brackets to insert as string.
;											"/only"    ()   ; don't recursively preprocess data, really just insert file here.
;											"/block"   ()   ; add output block brackets to essentially turn into a block of code (must be loadable data)
											"/binary"  ()   ; convert data into a binary, if possible, or generate an error.
;											"/mold"    ()   ; load and mold/all the code.  preserving some types.
										]
									]
								]
								;-----------------------
								; PUT ANY OTHER COMMAND DEFINITION HERE
								;-----------------------
							]
							
							;-----
							; identify the macro end, but don't make it part of the macro-code
							;
							; it is opt since a command may need no args.
							copy .macro-data opt [
								some =whitespace= 
								to =macro-end=
							]
						]
					]
					=macro-end=
					.macro-end:  
					there: ; just a backup to skip the macro if its spec is bad and it can't get to replace it.
					(
						;---
						; load the data (if any)
						v?? .cmd
						v?? .macro-data
						either string? .macro-data [
							.macro-data: load/all  .macro-data
						][
							.macro-data: copy []
						]
						v?? .macro-data
						
						v?? .refinements
						either string? .refinements [
							.refinements: load/all .refinements
						][
							.refinements: copy []
						]
						v?? .refinements
						
						;---
						; perform macro
						switch/default .cmd [
							"INCLUDE" [
								path: pick .macro-data 1
								
								v?? path
								
								either file? path [
	;---
									vprint ["INCLUDING :" path]
								
									; optimise path
									;
									path: clean-path path
		
									unless exists? path [
										vprint [ to-local-file path " Doesn't exist" ]
										to-error rejoin ["slap/preprocess/#include : " to-local-file path " Doesn't exist" ]
									]
									data: read path
									
									;---
									; store path
									cwd: what-dir
									
									;---
									; set working path to file being pre=processed
									change-dir directory-of path
									
									;---
									; using a recursive call to preprocess within parse, we are able to effectively cause 
									; stack use, since the values are all contextualised to the function context by funcl.
									data: preprocess/options data opt-blk
									
									
									vprobe length? data
									
									;---
									; restore our working path
									change-dir cwd
									
									if find .refinements /binary [
										data: mold as-binary data
									]
									
									;---
									; do the file data replacement.
									;
									; change/part returns the offset at the end of the change, so we can use it
									; directly within the parse as :there, later on.
									;---
									there: change/part .macro-start data .macro-end
								][
									to-error rejoin ["slap/preprocess() <#include ...#> expects a file!, (" mold path ") is invalid" ]
								]
							]
						][
							to-error rejoin ["slap/preprocess() unknown command : " .cmd ]
						]
					)
					
					;----
					; where do we set the cursor when the macro is done?
					:there 
				]
				| skip (i: i + 1   if i > 10'000 [prin "." i: 0])
			]
		]
		
		v?? destination
		;----
		; simple keyword substitution
		;-        - #SDK-PATH
		replace/all origin rejoin [=macro-start=  "SDK-PATH"  =macro-end= ] mold encap-path
		
		
		;----
		; write out the file if input was a filename.
		if destination [
			;---
			; restore the working dir to what we had when we entered the preprocess function
			change-dir pre-wd
			write destination origin
		]
		
		
		; destination: op-start: op-end: op: path: data: cwd: there: none
		data: .macro-data: .macro-end: .macro-start: none
		
		vprobe length? origin
		;ask ".."
		
		vout
		first reduce [origin  origin: none]
	]
	
		
	;--------------------------
	;-     sdk-prebol()
	;--------------------------
	; purpose:  let the sdk pre-process a file
	;
	; inputs:   
	;
	; returns:  the generated file name, so we can easily continue the toolchain
	;
	; notes:    this relies on the modified sdk toolchain by Maxim Olivier-Adlhoch.
	;
	; to do:    
	;
	; tests:    
	;--------------------------
	sdk-prebol: funcl [
		source-file [file!]
		/as out-name [word! file!]
		/to dest-dir "set output folder. can be relative (to distro) or absolute"
		/as-is "use the path as is, do not make it a distro-relative path"
		/within encap-wd "set the current-working-directory in order to align local paths."
		/pause "pause the encap process when it is done... allows to look at stats"
	][
		vin "sdk-prebol()"
		v?? source-file
		
		here: what-dir ; memorise where we are , is restored before quitting
		
		wd: either encap-wd [
			either absolute-path? encap-wd [
				 encap-wd
			][
				join distro-dir encap-wd
			]
		][
			distro-dir
		]
		v?? wd
		change-dir wd
		source-file: distro-path source-file

		output-file:   any [
			all [ 
				file? out-name
				out-name
			]
			all [
				word? out-name
				to-file rejoin [out-name ".r"]
			]
			to-file rejoin [ prefix-of source-file  "-preboled.r" ]
		]
		
		; when the source is a relativ path, use its folder as the base destination.
		if all [
			not dest-dir 
			not absolute-path? source-file
		][
			dest-dir: directory-of source-file
		]
		
		if dest-dir [
			output-file:    join dest-dir output-file
		]
		
		output-file:    distro-path output-file
		
		v?? source-file
		v?? output-file
		;ask "go!? ..."
		
		;source-code: read source-file
		
		vprint [ "Preprocessing :" mold/all source-file ]
		vprint [ "file size :    " get in (info? source-file) 'size " bytes" ]
		
		
		;-----------------
		; we now process-source() in a separate task because on large inputs, it busts the ram size!!
		;-----------------
		;   process-source/keep source-file
		;   write output-file mold/only result
		;   vprint ["result size: " length? mold/only result ]
		;   vprint ["saving as :  " output-file]
		;---
		execute rejoin [
			to-local-file pre-rebol-script
			" {"
			to-local-file source-file
			"} {"
			to-local-file output-file
			"} "
		]

		; reset path to the path on entry.
		change-dir here

		vout
		
		output-file
	]

	
	;--------------------------
	;-     encap()
	;--------------------------
	; purpose:  encap a file within the distro
	;
	; inputs:   
	;
	; returns:  the generated file name, so we can easily continue the toolchain
	;
	; notes:    we now prevent the REBOL preprocessor from touching our script, because it destroys them.
	;           unfortunately, serialized forms of values do not traverse the preprocessor in serialized form.
	;
	;           this means any serialized data in a block is automatically corrupted.
	;
	;           there is no workaround because the prebol script LOADs scripts rather than READs them.
	;           it is a block parser, not a string parser.   
	;
	;           use slap's own PREPROCESS function to replace the rebol prebol.
	;
	;           note that when encapping, you should usually create a file and put the standard rebol
	;           includes in it, prerebol THAT file, and then use PREPROCESS to include the result file 
	;           into your script.
	;
	;           encap always uses FRAME-SCRIPT before encapping.
	;
	; tests:    
	;--------------------------
	encap: funcl [
		source-file [file!]
		/as basis [word! file!]
		/to dest-dir [file!]"set output path."
		;/as-is "use the path as is, do not make it a distro-relative path"
		/within encap-wd "set the current-working-directory in order to align local paths."
		/pause "pause the encap process when it is done... allows to look at stats"

		;/local test out cmd
	][
		vin "slap/encap()"
		bin-ext: either platform-name = 'win32 [".exe"][""]
		source-file: distro-path source-file
				
		output-file: any [
			all [
				file? basis
				filename-of basis
			]
			all [
				word? basis
				rejoin [%"" basis bin-ext]
			]
			all [
				basis: prefix-of source-file
				join basis bin-ext
			]
			join to-file distro-name bin-ext
		]
		
		output-dir: dirize any [
			dest-dir
			directory-of source-file
			%./
		]
		
		output-exe-path: distro-path join output-dir output-file
		v?? output-exe-path
		
		;---
		; we manually pre-process the code.
		;
		; when its done in the same pass as the encap, there are bugs in the resulting apps related to object binding and #include files.
		; not sure why.
		
		v?? source-file
		source-code: read source-file
		
		vprint ["Preprocessing :" mold/all source-file ]
		vprint ["file size :    " length? source-code " bytes" ]
		
		source-code: frame-script source-code
		vprint ["file size after framing :    " length? source-code " bytes" ]
		
		
		
		pause?: either pause [" -p " ][""]

		cmd: rejoin [ "" to-local-file encap-exe pause? " -o " to-local-file output-exe-path  " " to-local-file source-file ]
		v?? cmd
		out: make string! 100'000
		test: call/shell/console/error/info cmd out
		v?? out

		vout
	]
	
	
	;--------------------------
	;-     frame-script()
	;--------------------------
	; purpose:  given a rebol script string, skip the header and surround the whole script in a do block.
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	frame-script: funcl [
		script [ string! ]
		/show-stats "in some cases we need to see if we are busting ram... show stats at each step."
	][
		vin "slap/frame-script()"
		if show-stats [vprint ["MEM 1: " (stats / 1'000'000) "MB"]]
		
		script: extract-script script
		vprint length? script
		
		if show-stats [vprint ["MEM 2: " (stats / 1'000'000) "MB"]]
		header: copy/part head script script
		
		if show-stats [vprint ["MEM 3: " (stats / 1'000'000) "MB"]]
		script: compress script
		if show-stats [vprint length? script]
		
		if show-stats [vprint ["MEM 3.5: " (stats / 1'000'000) "MB"]]
		recycle/off
		recycle/on
		
		if show-stats [
			vprint ["MEM 4: " (stats / 1'000'000) "MB"]
			vprint length? script
			vprint length? header 
		]
		
		if show-stats [vprint ["MEM 5: " (stats / 1'000'000) "MB"]]
		append header "^/do as-string decompress "


		if show-stats [vprint ["MEM 6: " (stats / 1'000'000) "MB"]]
		append header mold script 
		

		if show-stats [vprint ["MEM 7: " (stats / 1'000'000) "MB"]]
		clear script
		script: none
		
		recycle/off
		recycle/on
		
		
		if show-stats [vprint ["MEM 8: " (stats / 1'000'000) "MB"]]
		vout
		first reduce [header header: none ]
	]
	


	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- DISTRO FUNCTIONS
	;
	;-----------------------------------------------------------------------------------------------------------
	
	
	;--------------------------
	;-     --distro-root()
	;--------------------------
	; purpose:  an accessor which returns the current distro-dir value
	;
	; returns:  distro-dir
	;
	; notes:    since we cannot effectively expose literals, this replaces the use of distro-dir in slap files.
	;
	;           (DEPRECATED, useless)
	;           
	;--------------------------
;	--distro-root: func [
;	][
;		distro-dir
;	]
	


	;--------------------------
	;-     distro-path()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	distro-path: funcl [
		path [file!]
		/os "returns path in os format (as a string)"
		/undir "remove trailing slash if input was a dir"
	][
		;vin "slap/distro-path()"
		was-dir?: is-dir? path 
		unless absolute-path? path [
			path: clean-path join distro-dir path
		]
		if os [
			path: to-local-file path
			if was-dir? [
				path: dirize path
			]
		]
		if all [
			was-dir?
			undir
		][
			take/last path
		]
		;vout
		
		path
	]
	
	
	
	;--------------------------
	;-     get-last-distro()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	get-last-distro: funcl [
		/using root-path distro-spec [file!]
	][
		vin "slap/get-last-distro()"
		
		vout
	]
	
	

	
	;--------------------------
	;-     setup-distro()
	;--------------------------
	; purpose:  
	;
	; inputs:  
	;
	; returns:  
	;
	; notes:    if /root is given, module's 'ROOT-DIR  value is changed.
	;
	; tests:    
	;--------------------------
	setup-distro: funcl [
		name [word!] "We use a word to force a clean disk name.  Please don't use weird characters."
		/spec file-spec [block!] "a spec that will be reduced. note that <RELEASE> will be replaced by a padded, auto-incrementing release number."
		/release r "overide the release number, forces a prompt if this replaces an existing release"
		/source src "The source directory of this distribution."
		/root dest "The distributions root directory to which file-spec is added."
		/extern distro-name  distro-root-spec  source-dir  distro-dir  root-dir
	][
		vin "slap/setup-distro()"
		
		;-----
		; overide distro specs
		distro-name: name
		distro-root-spec: any [ file-spec  distro-root-spec ]
		
		root-dir: dirize clean-path any [dest root-dir]
		source-dir: dirize clean-path any [src source-dir]
		;unless exists? root-dir [ make-dir/deep root-dir ]
		
		;-----
		; manage release number
		unless release [
			r: any [ 
				all [
					i: get-current-release-number 
					i + 1
				]
				1
			]
		]
		distro-version: r
		
		update-distro-label r
		distro-dir: dirize join root-dir distro-label
		;distro-root: copy distro-dir
		
		v?? distro-dir
		
		;-----
		; make sure we don't overwrite a distro without user confirmation.      
		either exists? distro-dir [
			confirm?: ask rejoin [ "^/--------------------------^/WARNING ! a Distribution with this path: " distro-dir "^/already exists!^/^/ continuing will ERASE and rebuild this Distribution. ^/^/ press ^"Y^" and Enter to confirm, otherwise this script will abort." ] ; "^/"" ]  fix syntax highlighting
			either all [
				not empty? confirm?
				confirm/1 = "y"
			][
				cleanup %./ ; remember that path ops are distro-dir relative
			][
				quit    
			]
		][
			make-dir/deep distro-dir
		]
		v?? distro-dir
		vout
	]
	
	


	
	;--------------------------
	;-     update-distro-label()
	;--------------------------
	; purpose:  takes the distribution label setup and makes the internal version used by various tools.
	;
	; inputs:  
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	update-distro-label: func [
		release [integer! none!] "the release number, if any."
		/local rel spec
	][
		vin "slap/update-distro-label()"
		
		bind (spec: copy distro-root-spec ) self
		
		if all [
			release 
			rel: find spec <RELEASE> 
		][
			change rel zfill release release-number-padding
		]
		
		;-----
		; build the distro-dir path
		distro-label: rejoin spec
		
		vout
	]
	

	
	;-----------------
	;-     get-current-release-number()
	;-----------------
	get-current-release-number: func [
		;distro-name
		/override ospec [block!] "Replace spec with this one."
		/root oroot [file!] "Overide the path in which to find the distro."
		;/local d-list file i rnum  path spec =rule= current-version
	][
		vin "get-current-release-number()"
		spec: any [ ospec   copy distro-root-search-spec ]
		root: any [ oroot   root-dir ]
		
		either not release: find spec <RELEASE> [
			ask "^/--------------------------------^/WARNING: There is no explicit <RELEASE> tag to specify the distribution counter within your slap/distro-root-spec .^/Press enter to continue...^/"
		][
			;-----
			; by default, the first release is 001
			rnum: 1
			
			;----
			; setup the parse rule required to match the 
			=rule=: append copy [] rejoin copy/part spec release
			append =rule= [copy i some =digit= ]
			append =rule= copy next release
			append =rule= "/"
			
			;vprobe =digit=
			;vprobe =rule=
			
			current-version: 0
			
			;-----
			; get list of distributions already in our distributions folder
			if exists? root [
				d-list: read root
				;probe d-list
				
				foreach file d-list [
					;probe file
					file: to-string file
					if parse/all file =rule= [
						i: to-integer i
						;print ["release: " i]
						if i > current-version [
							current-version: i
							;rnum: i + 1
						]
					]
					;ask "."
				]
			]
			;v?? rnum
			;ask "!!!"
		]
		if current-version = 0 [
			current-version: 0
		]
		
		v?? current-version
		vout
		
		current-version
	]
	
		
	
		
	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- UTILITY FUNCTIONS
	;
	;-----------------------------------------------------------------------------------------------------------
	
	
	
	
	
	;--------------------------
	;-     set?()
	;--------------------------
	; purpose:  verifies if a word exists and evaluates to #[true]
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	set?: func [
		flag [any-type!]
	][
		all [
			value? get/any 'flag
			#[true] = get/any flag
		]
	]
	
	
	
	;--------------------------
	;-     distro-stats()
	;--------------------------
	; purpose:  
	;
	; inputs:  
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	distro-stats: func [
		
	][
		vin "slap/distro-stats()"
		v?? root-dir
		v?? distro-dir
		v?? source-dir
		v?? distro-name
		v?? distro-root-spec
		v?? distro-label
		vout
	]
	


	;--------------------
	;-     zfill()
	;--------------------
	zfill: func [
		"left fills the supplied string with zeros to amount size."
		string [string! integer!]
		length [integer!]
	][
		;vin/tags ["zfill()"] [zfill]
		if integer? string [
			string: to-string string
		]
		
		if (length? string) < length [
			head insert/dup string "0" (length - length? string)
		]
		;vout/tags [zfill]
		head string
	]
	
	

	
	;--------------------------
	;-     execute()
	;--------------------------
	; purpose:  execute a script, using the same interpreter path as the current
	;           like launch, but waits.
	;
	; inputs:   
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	execute: funcl [
		cmd [string!]
	][
		vin "slap/execute()"
		cmd:  rejoin [
			to-local-file system/options/boot
			" -qs --script "
			cmd
		]
		vprint mold new-line/all parse cmd " " true
		;ask "go >"
		call/wait/show cmd
		vout
	]
	


	;--------------------------
	;-     print-banner()
	;--------------------------
	; purpose:  prints a higly visible banner in the console.
	;
	; notes:    still obeys vprinting setup.
	;--------------------------
	print-banner: funcl [
		msg [string!]
	][
		vprint "^/----------------------------------------------------------------------------------------"
		vprint "----------------------------------------------------------------------------------------"
		vprint ["       " uppercase msg ]
		vprint "----------------------------------------------------------------------------------------"
		vprint "----------------------------------------------------------------------------------------"
	]


	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- FILE PROCESSING FUNCTIONS
	;
	;-----------------------------------------------------------------------------------------------------------


	;--------------------------
	;-     fix()
	;--------------------------
	; purpose:  given a list of one or more files or directories, replace one or more strings of texts by some other text.
	;
	; inputs:   files and fixes to perform on those files
	;           fixes are specified as pairs of strings, one to find, the other to replace it with.
	;
	; returns:  number of files successfully fixed
	;
	; notes:    - given folders are fixed recursively, which may take some time.
	;           - a file extension filter is applied on recursive fixes... preset this within fix-extensions: or use /only
	;           - providing anything else than a string for fixes raises an error.
	;           - /Line mode skips any whitespaces directly between your search and replace text.
	; tests:    
	;--------------------------
	fix: fix*: funcl [
		files [file! block!] ; distro-relative
		fixes [string! block!]
		/source "get the files in the source directory instead of the distro."
		/lines {Use line mode which searches string at start of line and replaces text AFTER it. 
If the replacement is a NONE value, it will erase that whole line.}
		;/local fix file data changed? dir path abs-path file? fix-to fixed-count file-list
	][
		vin [{fix()}]
		v?? files
		
		files: compose [(files)]
		fixes: new-line/skip compose [(fixes)]  true 2
		
		either source [
			dir: source-dir
		][
			dir: distro-dir
		]
		
		fixed-count: 0
		
		foreach path files [
		
			;----
			; verify the input
			either absolute-path? path [
				abs-path: path      
			][
				abs-path: join dirize dir path
			]
			
			abs-path: clean-path abs-path
			
			v?? abs-path
			
			unless exists? abs-path [
				print [ "fix() ERROR!! : file doesn't exist: " abs-path ]
				halt
			]
			
			if (file?: not is-dir? abs-path) <> (not dir? abs-path) [
				print [ "fix() ERROR!! : specified source path does not match its type on disk." ]
				print [ "spec is a        : " pick [ "file" "directory"] file? "  (" mold path ")" ]
				print [ "Path on disk is a: " pick ["file" "directory" ] not file? ]
				halt
			]
		
			either file? [
				;----
				; single file fix
				data: read abs-path
				;v?? abs-path
				
				changed?: false
				foreach [ srchstr  fix-to ] fixes [
				
					=replace-rule=: either none? fix-to [
						[
							; skip the newline if we're not at end of text
							opt [ #"^/" .line-end: ]
							(
								remove/part .line-start .line-end
								changed?: true
							)
							; reset cursor to start of line... text after it has been removed.
							:.line-start
						]
					][
						[
							(
								change/part here fix-to any [ all [ .foundstr length? .foundstr ] 0 ]
								there: skip here length? fix-to
								changed?: true
							)
							:there ; adjust cursor to end of fixed string
							
							;----
							; we now skip the trailing newline
							[
								some =newline=
								| end
							]
						]					
					][
					
					
					]
					;v??  srchstr
					either lines [
						;----------------------------------
						;-         -Line mode
						;
						; look here for dev reference: C:\dev\tests\slap-fix-line-parse-dev.r
						parse/all data [
							any [
									[
										.line-start:
										
										;---
										; skip search string AND any traling space, so indents are kept.
										any =whitespace=
										srchstr
										any =whitespace=
										
										;---
										; select the rest of line, this will be replaced (note: we do not include the trailing new line...)
										copy .foundstr [
											here:
												[
													to "^/"
													| to end
												]
											there:
										]
										.line-end:
										=replace-rule=
									]
									| [	some =text= =newline= ]
									| [	=newline= ]
								]
							]
					][
						;----------------------------------
						;-         -search replace mode
						unless changed? [
							if find data srchstr [
								changed?: true
							]
						]
						replace/all data srchstr fix-to
					]
					;]               
				]
				
				;vprobe data
				either changed? [
					write abs-path data
					fixed-count: fixed-count + 1
					vprint ["Fixed:  " abs-path]
				][
					vprint ["Nothing to fix: " abs-path]
				]
			][
				;----
				; directory tree fix (recursive)
				file-list: dir-tree/absolute abs-path
				
				vprobe file-list

				foreach path file-list [
					if is-dir? path [
						;vprint ["fixing path: " path]
						fix* path fixes
					]
				]
				
			]
		]
		
;       vprint "----------------->"
;       vprint copy/part data 3000
;       vprint "<-----------------"
;       vout
;       v?? file

		file-list: changed?: files: fixes: file-list: data: fix: fix-to: abs-path: dir: none

		vout
		
		fixed-count
	]


	



	
	;--------------------------
	;-     extract-script()
	;--------------------------
	; purpose:  given a text file, returns the text after the header.
	;
	; inputs:   
	;
	; returns:  the script or none.
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	extract-script: funcl [
		data
	][
		vin "slap/extract-script()"
		;---
		; skip the first 'REBOL word we find (just like the interpreter).
		until [
			blk: load/next data
			
			;v?? blk
			
			item: pick blk 1
			data: pick blk 2
		
			any [
				none? blk
				empty? data
				none? data
				tail? data
				item = 'rebol
			]
		]
		
		vprint type? data
		
		;---
		; skip the block after it
		if all [
			data
			string? data
			not empty? data
			not empty? blk: load/next data
		][
			if block? pick blk 1 [
				data: pick blk 2
			]
		]
		
		;---
		; make sure data is a script or none
		data: all [
			string? data
			not empty? data
			data
		]
		
		
			
		vout
		first reduce [ data   data: blk: item: none ]
	]
	
	
	

	




	;--------------------------
	;-     archive()
	;--------------------------
	; purpose:  given a root-path, it will compress all files inside and consolidate them into one block of binaries.
	;
	; inputs:   
	;
	; returns:  a context which has all the meta and binary data.
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	archive: funcl [
		root [file!]
	][
		vin "slap/archive()"
		files: sort dir-tree root
		
		blk: []
		
		ctx: context [
			files: blk
		]
		
		foreach file files [
			vprint ["packing: " join root file]
			append blk file
			either is-dir? file [
				append blk none
			][
				append blk compress read/binary join root file
			]
		]
		
		vprobe files
		vout
		first reduce [ blk    blk: file: ctx: files: root: none ]
		
	]
	
	
	
	
	;--------------------------
	;-     blow()
	;--------------------------
	; purpose:  given an archive object, blows it back to disk.
	;
	; inputs:   
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	blow: funcl [
		archive [block!]
		install-dir [file!]
		/hook callback [function!]
	][
		vin "slap/blow()"
		l: (length? archive) / 2 ; length
		
		foreach [file data] archive [
			wait 0 ; when its within a GUI... allows it to react/refresh
			i: i + 1
			path: clean-path join install-dir file
			
			if hook [
				callback i l install-dir file data
			]
			vprint to-local-file path
			v?? i
			
			either data [
				data: decompress data
				write/binary path data
			][
				make-dir/deep path
			]
		]
		vout
	]
	




	;-----------------
	;     slim-link()
	;
	; DEPRECATED function
	;-----------------
	slim-link: func [][to-error "slap/slim-link(): deprectated function, update to link-slim()"]


	;-----------------
	;-     link-slim()
	;
	; takes a file and slim-links it.
	;
	; all paths are relative to distro dir
	;
	; NOTE: the slim link lib and all paths leading to required libs MUST be setup prior.
	;-----------------
	link-slim: funcl [
		input-path [file!]
		/to output-path [file!]
		/local input-dir input-file output-file output-dir data success?
	][
		vin [{link-slim()}]
		
		;----
		; must specify an input
		if input-file: filename-of input-path [
			input-dir: any [ directory-of input-path copy %./ ]
			
			either to [
				;----
				; try to use whatever is given within output path, use input 
				; as the default for the rest
				output-dir:  any [directory-of output-path   input-dir]
				output-file: any [filename-of  output-path   input-file]
			][
				;----
				; use the input-path to build an output path automatically
				output-dir:  input-dir
				output-ext:  extension-of input-file
				output-file: copy/part input-file ((length? input-file) - (length? output-ext) - 1)
				output-file: rejoin [output-file %-linked "." output-ext]
			]
			
			output-path: join output-dir output-file
			
			unless absolute-path? input-path [
				input-path: join distro-dir input-path
			]
			unless absolute-path? output-path [
				output-path: join distro-dir output-path
			]
			
			input-path: clean-path input-path
			output-path: clean-path output-path
		
			v?? input-path
			v?? output-path
	
			; link the file
			data: linker/link input-path
			
			; save it out.
			write output-path data
			
			; just a little wait to be sure the app has finihsed flushing to disk before sending
			; new call commands. (yes, I've had problems with this on windows)
			wait 0.1
			
			success?: true
		]
	
		vout
		
		success?
	]
	
	
	
	


	
	
	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- FILE OPERATION FUNCTIONS
	;
	;-----------------------------------------------------------------------------------------------------------
	

	

	
	;--------------------------
	;-     fetch()
	;--------------------------
	; purpose:  take a file from the distro (or any absolute path) and dump in the source 
	;
	; inputs:   file path
	;
	; returns:  computed destination path
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	fetch: func [
		src [file!] "Source file or folder to copy within the distribution.  Paths must respect their disk types (file or directory), any mismatch generates an error."
		/as as-file [file!]  "Alternate destination/name.  must match the src filetype (file or directory)."
		/to to-dir [file!] "Dump to a different path within the distro. MUST be a directory path.  You can use absolute paths."
		;/fetch
		/local dest
	][
		vin "slap/fetch()"
		dest: apply :dump [src as as-file to to-dir  #[true]]
		vout
		dest
	]
	
	
	
	;--------------------------
	;-     duplicate()
	;--------------------------
	; purpose:  copies a file within the distro.
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; to do:    
	;
	; tests:    
	;--------------------------
	duplicate: funcl [
		src [file!]
		dest [file!]
	][
		vin "duplicate()"
		src:  distro-path src
		vout/return
		dump-file src dest
	]
		
	
	;--------------------------
	;-     dump()
	;--------------------------
	; purpose:  
	;
	; inputs:  /ignore only makes sense for folder dumps.
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	dump: func [
		src [file! block! word!] "Source file or folder to copy within the distribution.  Paths must respect their disk types (file or directory), any mismatch generates an error."
		/copy "The source and destination are both within destination."
		/as as-file [file!]  "Alternate destination/name.  must match the src filetype (file or directory)."
		/to to-dir [file!] "Dump to a different path within the distro. MUST be a directory path.  You can use absolute paths."
		/fetch "inverses the meaning of the distro and source directories"
		/ignore ignore-list [file! block!] "one or more explicit files or folders to ignore. (only considers last part of folder or file name."
		/filter exclude-list [block! file! string! none!] {file names or subparts you want to ignore, equal to "*text*".  so you can do ".xml" to ignore all XML files }
		/local src-type file? dest abs-src  lcl-distro-dir lcl-source-dir file rblk
	][
		vin "slap/dump()"
		v?? src
;		v?? as
;		v?? as-file
;		v?? to
;		v?? to-dir
;		v?? fetch
;		v?? ignore-list
;		vprint "-----------------------"
		
		
		;---------------------------------
		; manage special src types
		;
		case [
			block? src [
				rblk: copy* []
				foreach file src [
					append rblk apply :dump [  file  copy  as  as-file  to  to-dir fetch ignore ignore-list filter exclude-list ]
				]
				vout
				return rblk
			]
			
			;------------------
			; script name (usefull for list of slim libraries)
			any [word? src   lit-word? src ] [
				src: to-file rejoin [ "" src ".r" ]
			]
		]
		
		either fetch [
			lcl-distro-dir: source-dir
			lcl-source-dir: distro-dir
		][
			lcl-distro-dir: distro-dir
			lcl-source-dir: source-dir
		]
		
		if copy [ 
			vprint "copying a file in distro!"
			lcl-source-dir: lcl-distro-dir 
		]
		;----
		; we cannot ask for /AS and /TO in the same call.
		if all [
			as
			to
		][
			print ["dump() ERROR: /AS and /TO are mutually exclusive, you can not use dump() with both."]
			halt
		]
		
		;----
		; verify the input
		either absolute-path? src [
			abs-src: src
		][
			abs-src: join dirize lcl-source-dir src
		]
		file?: not is-dir? abs-src
		
		;v?? lcl-source-dir
		;v?? lcl-distro-dir
		;v?? abs-src
		
		
		if (file?) <> (not dir? abs-src) [
			print [ "Dump() ERROR!! : specified source path does not match its type on disk." ]
			print [ "spec is a        : " pick [ "file" "directory"] file? "  (" mold abs-src ")" ]
			print [ "Path on disk is a: " pick ["file" "directory" ] not file? ]
			halt
		]
		
		;----
		; src and as-file must be of the same type
		if all [
			as-file
			file? <> (not is-dir? as-file)
		][
			print ["dump() ERROR: /AS as-file must match the path type (file or directory) given in src argument."]
			halt
		]
		
		;----
		; to-dir must be a dir
		if all [
			to
			not is-dir? to-dir
		][
			print ["dump() ERROR: /TO to-file must be a directory path."]
			halt
		]
		
		
		;----
		; destination filename is the same as source by default... some options may change this
		dest: src
		
		;v?? dest
		;v?? src
		
		;----
		; absolute src dirs REQUIRE a /TO or /AS path
		if all [
			absolute-path? src
			not any [ to as ]
		][
			print "Setting destination within root of distro"
			dest: file-part src
			;print [ "dump() ERROR: Absolute source paths, require you provide one of /TO or /AS refinements.^/Path given: " src ]
			;halt
		]
		
		;----
		; generate the destination path
		dest: case [
			as [
				; /AS is a direct specification for the output path in both file and dir paths.
				either file? [
					either dir-part as-file [
						as-file
					][
						;--
						; as-file with no path simply renames the file within the same dir depth
						; as in the lcl-source-dir
						; use %./  to force the file to be put within the root of the distro.
						to-file rejoin [
							any [ dir-part src ""]
							file-part as-file
						]
					]
				][
					as-file
				]
			]
			to [
				; /TO is an alternative directory, in which to place the content of a file.
				;  keeping the top level part of the source path when its a directory.
				either file? [
					join to-dir file-part src
				][
					; we cover any src path, even the root of the lcl-source-dir!
					rejoin [ to-dir   any [second split-path src "" ] ]
				]
			]
			
			'default [
				dest
			]
		]
		;v?? fetch
		;v?? src
		;v?? abs-src
		;v?? dest

		;----------------
		; don't put it in the list if you don't want it
		;		if all [
		;			file? ignore
		;			find ignore-list (file-part src) 
		;			(vprint "ignoring file" vout return none)
		;		]
		;----------------
		
		dest: any [
			all [file? fetch  (dump-file/fetch abs-src dest) ]
			all [file?  (dump-file abs-src dest) ]
			all [fetch ignore (dump-dir/fetch/ignore/filter abs-src dest ignore-list exclude-list)]
			all [fetch  (dump-dir/fetch/filter abs-src dest  exclude-list)]
			all [ignore (dump-dir/ignore/filter abs-src dest ignore-list  exclude-list)]
			dump-dir/filter abs-src dest  exclude-list
		]
		
		vout
		dest
	]
	
	
	
	;--------------------------
	;-     dump-file()
	;--------------------------
	; purpose:  transfers a FILE from the source to distro (or vice-versa if /fetch is used)
	;
	; inputs:   two paths, absolute or relative
	;
	; returns:  the computed destination path
	;
	; notes:    DOES NO ERROR CHECKING.  DO NOT USE THIS MANUALLY.
	;
	; tests:    
	;--------------------------
	dump-file: func [
		src [file!]
		dest [file! none!]
		/fetch
		/local lcl-distro-dir lcl-source-dir a
	][
		vin "slap/dump-file()"
		v?? fetch
		v?? src
		v?? dest
		either fetch [
			lcl-distro-dir: source-dir
			lcl-source-dir: distro-dir
		][
			lcl-distro-dir: distro-dir
			lcl-source-dir: source-dir
		]


		unless absolute-path? src [
			src: join lcl-source-dir src
		]
		
		unless absolute-path? dest [
			dest: join lcl-distro-dir dest
		]
		
		src:  clean-path src
		dest: clean-path dest

		vprint rejoin [
			"---" newline
			"Dumping file to "  either fetch ["SLAP SOURCE:"]["DISTRO:"]  newline 
			"  FROM: " src newline 
			"  TO:   " dest  newline 
		]
			
		unless exists? dir-part dest [make-dir/deep dir-part dest]

		;write/binary dest a: read/binary src
		os-copy src dest

		;clear a
		;a: none

		vout
		dest
	]
	
	
	
	
	;--------------------------
	;-     dump-dir()
	;--------------------------
	; purpose:  transfers a DIRECTORY tree from the source to distro (or vice-versa if /fetch is used)
	;
	; inputs:   two paths, absolute or relative
	;
	; returns:  the computed destination path
	;
	; notes:    DOES NO ERROR CHECKING.  DO NOT USE THIS MANUALLY.
	;
	; tests:    
	;--------------------------
	dump-dir: funcl [
		src [file!]
		dest [file! none!]
		/fetch
		/ignore ignore-list [file! block!]
		/filter exclude-list [block! file! string! none!] {file names or subparts you want to ignore, equal to "*text*".  so you can do ".xml" to ignore all XML files }
		;/local lcl-distro-dir lcl-source-dir
	][
		vin "slap/dump-dir()"
		
		ignore-list: all [ignore compose [(ignore-list)]]
		
		either fetch [
			lcl-distro-dir: source-dir
			lcl-source-dir: distro-dir
		][
			lcl-distro-dir: distro-dir
			lcl-source-dir: source-dir
		]

		unless absolute-path? src [
			src: join lcl-source-dir src
		]
		
		unless absolute-path? dest [
			dest: join lcl-distro-dir dest
		]
		

		src:  clean-path src
		dest: clean-path dest

		vprint rejoin [
			"---" newline
			"Dumping DIRECTORY to distro:"  newline 
			"  FROM: " src newline 
			"  TO:   " dest  newline 
		]
		
		unless exists?  dest [make-dir/deep dest]
		
		copy-dir/ignore/filter   src dest ignore-list exclude-list
		vout
		
		dest
	]
	
	
	
	;--------------------------
	;-     rename*()
	;--------------------------
	; purpose:  rename a file or directory within the distro
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	rename*: funcl [
		from   [file!]
		to     [file!] "must not include a path part, if the spec is a dir, it must be the top dir."
	][
		vin "slap/rename*()"
		
		from: distro-path from
		
		
		v?? from
		v?? to
		
		rename  from to
		
		vout
	]
	
	
	

	
	;-----------------
	;-     cleanup()
	;
	; removes a file or a directory from the distribution
	;
	; usefull when we copy a whole directory but want to remove some files out of it.
	;-----------------
	cleanup: func [
		paths [file! block!]
		/source "cleans the source directory, not the distro"
		/content "removes files INSIDE any given folder path, erases content (file 0 bytes) when given a file path."
		/local file?
	][
		vin [{cleanup()}]
		paths: compose [(paths)]
		
		foreach path paths [
			unless absolute-path? path [
				either source [
					path: join source-dir path
				][
					path: join distro-dir path
				]
			]
			
			if exists? path [
				;----
				; verify the input
				if (file?: not is-dir? path) <> (not dir? path) [
					print [ "cleanup() ERROR!! : specified source path does not match its type on disk." ]
					print [ "spec is a        : " pick [ "file" "directory"] file? "  (" mold path ")" ]
					print [ "Path on disk is a: " pick ["file" "directory" ] not file? ]
					halt
				]
				
				;v?? path
				;print is-dir? path
				;print not dir? path
				;print exists? path
				;ask "??"
					
				either exists? path [
					v?? path
					either dir? path [
						either content [
							;---
							; we clear the content of the folder
							list: read path
							foreach item list [
								delete-dir join path item
							]
						][
							delete-dir path
						]
					][
						either content [
							;---
							; we simply clear the content of the file.
							write path ""
						][
							delete path
						]
					]
				][
					vprint ["file doesn't exist: " path]
				]
			]
		]
		
		vout
	]





	;-----------------
	;-     create-dir()
	;-----------------
	create-dir: func [
		path [file! block!]
	][
		vin "creating directories"
		paths: compose [(path)]
		
		foreach path paths [
			path: clean-path join distro-dir dirize path
			vprobe path
			make-dir/deep  path
		]
		vout
	]
	


	;-----------------
	;-     absolute-path?()
	;-----------------
	absolute-path?: func [
		path [file!]
	][
		#"/" = pick path 1 ; also works with empty paths!
	]
	
	
	
	
	;-------------------
	;-     is-dir?()
	;-----
	is-dir?: funcl [path [string! file!]][
;		path: to-string path ; copies input even when a string...
;		replace/all path "\" "/"
;		
;		all [
;			path: find/last/tail path "/"
;			tail? path
;		]
		
		;---
		; this should be a much faster implementation.
		all [
			0 < length? path
			any [
				#"/" = tailchar: last path
				#"\" = tailchar
			]
		]
	]
	
	

	;-----------------
	;-     -dir-tree()
	;-----------------
	-dir-tree: funcl [
		path [file!]
		/root rootpath [file! none!]
		/absolute "returns absolute paths"
		/ignore ignore-list [block! none!] "doesn't list these"
		/filter exclude-list [block! file! string! none!] {file names or subparts you want to ignore, equal to "*text*".  so you can do ".xml" to ignore all XML files }
		;/local list item data subpath dirpath rval
	][
		;vin "dir-tree()"
		;v?? rootpath
		rval: copy []
		either root [
			unless exists? rootpath [
				?? clean-path rootpath
				to-error rejoin [ "compiler/dir-tree()" path " does not exist" ]
			]
		][
		;	vprobe "NO ROOT"
			either is-dir? path [
				rootpath: path
				path: %./
			][
				to-error rejoin [ "compiler/dir-tree()" path " MUST be a directory." ]
			]
		]
		
		dirpath: clean-path append copy rootpath path
		
		
		either is-dir? dirpath [
			; list directory content
			if none? attempt [ 
				list: read dirpath
			][
				print  ["error: unable to read: " dirpath ]
				halt
			]
			
			; append that path to the file list
			append rval path
			
			foreach item list [
						
				unless all [
					ignore-list
					not empty? ignore-list
					find ignore-list to-string item
				][
					subpath: join path item
					
					; list content of this new path item (files are returned directly)
					either absolute [
						data: dir-tree/root/absolute/ignore/filter subpath rootpath ignore-list exclude-list
					][
						data: dir-tree/root/ignore/filter subpath rootpath ignore-list exclude-list
					]
					;---
					; data may be a file or a block of files/folders
					if (length? data) > 0 [
						append rval data
					]
				]
			]
		][
			if exclude-list [
				switch/all type?/word exclude-list [
					file! string! [
						exclude-list: reduce [as-string exclude-list]
					]
					block! file! string![
						;vprint "filtering out exclude-list"
						;v?? path 
						;v?? exclude-list
						foreach text exclude-list [
							if find path text [
								;vprint "skipping! this file"
								;ask "..."
								return ""
							]
						]
						;ask "..."
					]
				]
			]
					
			if absolute [
				path: clean-path join rootpath path
			]
			; when the path is a file, just return it, it will be compiled with the rest.
			rval: path
		]
		
		if block? rval [
			rval: new-line/all  head sort rval true
		]
		
		;v?? root
		;unless root [
		;v?? rval
		;]
		;vout
		rval
	]

	
	
	;-----------------
	;-     copy-dir()
	;-----------------
	copy-dir: funcl [
		source  [file!]
		dest [file!]
		/ignore ignore-list [block! none!] "VERY SIMPLE list of files to ignore. no differentiation between folders and files."
		/filter exclude-list [block! file! string! none!] {file names or subparts you want to ignore, equal to "*text*".  so you can do ".xml" to ignore all XML files }
		;/local list
	][
		vin [{copy-dir()}]
		
		v?? ignore-list
		
		either ignore-list [
			ignore-list: copy ignore-list
			forall ignore-list [
				change ignore-list to-string first ignore-list
			]
			ignore-list: head ignore-list
		][
			ignore-list: []
		]
		either is-dir? dest [
			flist: dir-tree/ignore/filter source ignore-list exclude-list
			;v?? flist
			
			foreach file flist [
				path-bits: itemize-path file
				;v?? path-bits
				;v?? ignore-list
				;vprobe intersect ignore-list path-bits
				
				either empty? intersect ignore-list path-bits [
					either is-dir? file [
						make-dir/deep join dest file
					][
						vprobe clean-path join dest file
						os-copy  clean-path join source file   clean-path join dest file
						;write/binary join dest file read/binary vprobe clean-path join source file
					]
				][
					vprint [ "IGNORING: " join source file]
				]
			]
		][
			to-error "copy-dir() destination is not a directory"
		]
		vout
	]
	
	
	
	;-----------------
	;-     file-part()
	;-----------------
	file-part: func [
		path [file!]
		/local file
	][
		if file: any [
			find/tail/last path "/"
			path
		][
			file: unless empty? file [
				copy file
			]
		]
		file
	]
	
	
	;-----------------
	;-     dir-part()
	;-----------------
	dir-part: func [
		path [file!]
		/local file dir
	][
		if file: find/tail/last path "/" [
			dir: copy/part path file
		]
		dir
	]
	
	
	
	;--------------------------
	;-     ext-part()
	;--------------------------
	; purpose:  returns the extension part of a file path
	;
	; inputs:   a file path
	;
	; returns:  -the extension of the file, or none, if its a directory (even if it contains a "." in the path)
	;           -we silently ignore none inputs by returning none
	;
	; notes:    -we rely only on the file path given, not its actual disk type to verify if the input is indeed a directory.
	;
	; tests:    
	;--------------------------
	ext-part: func [
		file [file! none!]
		/local ext
	][
		vin "slap/ext-part()"
		ext: none ; prevent reuse of a previous call to ext-part() static pointer to ext
		
		if file [
			if is-dir? file [
				print ["ext-part() ERROR: must provide a FILE path, not a directory path (given: " file ")."]
			]

			if ext: find/last/tail file "."  [
				ext: copy ext
			]
		]

		vout

		ext

	]
	
	
	
	
	
	;-                                                                                                       .
	;-----------------------------------------------------------------------------------------------------------
	;
	;- UNREVISED
	;
	;-----------------------------------------------------------------------------------------------------------
	
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;
	;                                                                   unverified old code
	;
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	
	
	;--------------------------
	;-     pack-rip()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	pack-rip: funcl [
	][
		vin "slap/pack-rip()"
		source-path [file!]
		output-root [file!] "Use this as the root when storing files within the archive."
		vout
	]
	
	
	
	;-----------------
	;-     rip()
	;
	; takes the rip script from rebol.org and reformats it for this build system
	;-----------------
	rip: func [
		/save-to output-path [file!]
		/force "If files exist, don't ask for any confirmation"
		/local output-file output-dir archive file-list file files header from-size to-size from-total path
	][
		vin [{rip()}]
	
	;   path: to-file ask {
	;   Enter the relative directory path.
	;   Press RETURN key for current directory,
	;   or type a path in the form: dir/dir/dir
	;   
	;   Directory? }
		
		;if empty? path [path: %./]
		;if (last path) <> #"/" [append path #"/"]
		source-path: dirize source-path
		
		
		v?? source-path
		v?? output-path
		v?? output-root
		;ask "!"
		
		if not exists? source-path [vprint [path "does not exist"] halt]
		
		file-list: copy []
		archive: make binary! 32000
		from-total: 0
		vprint "Archiving:"
		foreach file files: read source-path [
			either dir? source-path/:file [
				append file-list reduce [file 'DIR ]
				foreach newfile read source-path/:file [append files file/:newfile]
			][
				data: read/binary source-path/:file
				from-size: length? data
				from-total: from-total + from-size
				data: compress data
				to-size: length? data
				vprint [file "         " from-size " -> " to-size]
				append archive data
				append file-list reduce [file length? data]
			]
		]
		
		vprint [newline "Total size:" length? archive " (From: " from-total ",  " 100 * (1 - (round/to ( ( length? archive) / from-total ) 0.001)) "% reduction )   Checksum:" checksum archive newline]
		
		;output-file: to-file ask "Output archive file name? "
		;if empty? output-file [output-file: %archive.rip]
		
		if save-to [
			unless output-file: file-part output-path [
				output-file: %archive.rip
			]
			output-dir: any [dir-part output-path %./]
			
			if not find output-file "." [append output-file ".rip"]
			
			; uniformitize the output path back into a single path, based on any path fixing we did above
			output-path: join output-dir output-file
			
			if all [
				exists? output-path 
				not force
				not confirm reform ["Overwrite file" output-path "? "]
			][
				print "stopped" halt
			]
		]
		;set [ignore file] split-path output-path
		;file: to-file file  ; for 2.2 compat
		;file: output-file
		
		header: mold compose/deep/only [
			REBOL [
				Title: "REBOL Self-extracting Binary Archive (RIP)"
				Date: (now/date)
				File: (output-file)
				Note: (reform [{To extract, type REBOL} file {or run REBOL and type: do} file])
			]
			file: (output-file)
			size: (length? archive)
			path: (output-root)
			verbose: not all [system/script/args system/script/args = 'quiet]
			files: (new-line/skip file-list true 2)
			check: (checksum archive)
			if not exists? path [make-dir/deep path]
			archive: read/binary file
			archive: next find/case/tail archive to-binary join "!DATA" ":"
			
			;if check <> checksum archive [print ["Checksum failed" check checksum archive] halt]
			
			foreach [file len] files [
				;if verbose [print [tab file]]
				either len = 'DIR [
					if not exists? path/:file [make-dir/deep path/:file]
				][
					?? len
					data: copy/part archive len
					;write/binary %data.rip data
					;probe data
					;ask "?"
					data: decompress data
					;ask "!"
					archive: skip archive len
					either any [
						not exists? path/:file
						confirm reform [file "already exists - overwrite? "]
					][
					write/binary path/:file data][print "skipped"]
				]
			]
			none
		]
		
		insert archive reduce [header newline "!DATA:" newline]
		
		if save-to [
			v?? output-path
			write/binary output-path archive
		]
		
		vout
		
		first reduce [ archive archive: none ]
	]
	
]

;------------------------------------
; We are done testing this library.
;------------------------------------
;
; test-exit-slim
;
;------------------------------------

