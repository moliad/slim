rebol [
	; -- Core Header attributes --
	title: "SLAP | Slim Application packager"
	file: %slap.r
	version: 1.0.0
	date: 2013-9-9
	author: "Maxim Olivier-Adlhoch"
	purpose: {Automated integration, packaging and linking of application distribution.}
	web: http://www.revault.org/modules/slap.rmrk
	source-encoding: "Windows-1252"
	note: {slim Library Manager is Required to use this module.}

	; -- slim - Library Manager --
	slim-name: 'slap
	slim-version: 1.2.1
	slim-prefix: none
	slim-update: http://www.revault.org/downloads/modules/slap.r

	; -- Licensing details  --
	copyright: "Copyright © 2013 Maxim Olivier-Adlhoch"
	license-type: "Apache License v2.0"
	license: {Copyright © 2013 Maxim Olivier-Adlhoch

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at
	
		http://www.apache.org/licenses/LICENSE-2.0
	
	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.}

	;-  / history
	history: {
		v1.0.0 - 9-Sep-2013
			-license change to Apache v2}
	;-  \ history

	;-  / documentation
	documentation: {
		Slap is not yet documented, but mainly it works by building a distribution folder 
		into which you can copy and manipulate any files.  The system includes a way to automatically
		number the distributions folders.

		All functions deal in the distribution automatically or have it as the destination.
}
	;-  \ documentation
]



;--------------------------------------
; unit testing setup
;--------------------------------------
;
; test-enter-slim 'slap
;
;--------------------------------------

slim/register [
	zipper: slim/open 'zipper none
	
	slim/open/expose 'utils-files none [ substitute-file ] 
	
	
	;- GLOBALS
	;--------------------------------------
	; these are defaults, overide at will
	;--------------------------------------
	
	
	;--------------------------
	;-     root-dir:
	;
	; the root of all distributions
	;
	; after you call setup-distro, it will be an absolute path.
	;--------------------------
	root-dir: %distributions/
	

	;--------------------------
	;-     distro-dir:
	;
	; the destination path of all distro operations, may be changed on the fly.
	;--------------------------
	distro-dir: none
	
	
	;--------------------------
	;-     distro-root:
	;
	; the root of the distro generated by 'DISTRO-ROOT-SPEC
	;
	; this path is ever only changed when we use setup distro, so you can use it
	; in order to manually change 'DISTRO-DIR based on the root of the distribution.
	;--------------------------
	distro-root: none
	
	
	
	
	;--------------------------
	;-     source-dir:
	;
	; the explicit source directory.
	; note that this path should be an absolute path after setup-distro()
	; is performed.
	;--------------------------
	source-dir: %./
	
	
	;--------------------------
	;-     distro-name:
	;
	; the general name of this distribution.
	;--------------------------
	distro-name: 'build
	
	
	;--------------------------
	;-     distro-root-spec:
	;
	; the specification of how the distro-dir is built.
	;
	; this will be used by setup in order to build the distro-dir path.
	;
	; it is also used by the get-current-release-number() function.
	;
	; NOTE:  DO NOT INCLUDE THE TRAILING "/" IN THE SPEC.
	;--------------------------
	distro-root-spec: [ distro-name "-r" <RELEASE> ]
	
	
	;--------------------------
	;-     distro-label:
	;
	; the specific label of the distribution's
	; current setup.
	;
	; after setu-distro, this will be the reducec distro-root-spec
	;--------------------------
	distro-label: distro-name
	
	
	
	;--------------------------
	;-     release-number-padding:
	;
	; how many 0 padding do we need in the release number of distro-label?
	;--------------------------
	release-number-padding: 3
	
	
	
	;--------------------------
	;-     fix-extensions:
	;
	; when doing a recursive fix operation, only fix files with the following
	; extensions in them.
	;
	; these should only be ascii/utf8 files.
	;
	; note that this list is NOT used when FILE path are given to fix. it will always fix explicit files you tell it to.
	;--------------------------
	fix-extensions: ["txt" "r" "rmrk" "doc" "c" "h" "cp" "cpp" "cs" "html" "css" "js" "php" "asp" "aspx" "j" "jsp"]
	
	
	;--------------------------
	;-     ENCAP-ATTRIBUTE:
	;--------------------------
	encap-path: none
	encap-exe: none
	encap-includes: none
	prebol-script:  none
	pre-rebol-script: none
	encapped-exe-file: none
	encapped-script-file: none
	
	
	
	;--------------------------------------------------------------------------------------------------
	;-
	;- PARSE RULES
	;
	;--------------------------------------------------------------------------------------------------

	;--------------------------
	;-     =digits=:
	;--------------------------
	=digit=: charset "0123456789" 


	;--------------------------
	;-     =whitespace=:
	;--------------------------
	=whitespace=: charset "^- "
	
	
	;--------------------------
	;-     =separator=:
	;--------------------------
	=separator=: charset "^- ^/()[]{}^""



	;--------------------------------------------------------------------------------------------------
	;-  
	;- ENCAP FUNCTIONS
	;
	;--------------------------------------------------------------------------------------------------
	

	;--------------------------
	;-     setup-encap()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	setup-encap: func [
		sdk-dir [ file! ]
		/cmd  "use encmd.exe"
		/view "use enface.exe"
		/base "use enbase.exe"
		/basis   [word!]
		/tmp tmpscript [file!]
		/output out-name [ word! file! ] "file! is used as-is... word! gets .exe appended"
		/local encapper
	][
		vin "slap/setup-encap()"
		encap-path: clean-path sdk-dir
		
		encapper: any [
			all [ cmd     %encmd.exe  ]
			all [ base    %enbase.exe ]
			all [ view    %enface.exe ]
			%encmdview.exe 
		]
		
		if basis [
			out-name: basename
			tmpscript: to-file rejoin [ basename  "-preboled.r" ]
		]
		
		
		out-name: any [
			out-name
			distro-name
		]
		
		encap-exe: rejoin [ encap-path %tools/ encapper ]
		encap-includes: join encap-path %source/
		prebol-script: rejoin [ encap-path %tools/ %prebol.r ]
		
		pre-rebol-script: rejoin [ encap-path %tools/ %prerebol.r ]
		
		encapped-script-file: any [ 
			; preboled filename given
			all [
				tmp
				any [
					all [ absolute-path? tmpscript tmpscript ]
					join distro-dir tmpscript
				]
			]
			
			; default
			to-file rejoin [ out-name  "-preboled.r" ]
		]
		
		if word? out-name [
			out-name: to-file rejoin [ out-name  ".exe" ]
		]
		encapped-exe-file:  out-name
		
		do prebol-script
		vout
	]
	
	
	


	
	;--------------------------
	;-     encap()
	;--------------------------
	; purpose:  encap a file within the distro
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	encap: funcl [
		source-file [ file! ]
		/as basis [word!]
		/to dest-path"set output path."
		/as-is "use the path as is, do not make it a distro-relative path"
		/within encap-wd "set the current-working-directory in order to align local paths."
		/pause "pause the encap process when it is done... allows to look at stats"

		;/local test out cmd
	][
		vin "slap/encap()"
		
		here: what-dir ; memorise where we are 
		
		wd: either encap-wd [
			either absolute-path? encap-wd [
				 encap-wd
			][
				join distro-dir encap-wd
			]
		][
			distro-dir
		]
		
		v?? wd
		change-dir wd
		source-file: distro-path source-file

		preboled-path:    encapped-script-file
		output-exe-path:  encapped-exe-file
		
		
		
		basis: any [
			basis
			all [ 
				prefix: file-part source-file
				any [
					all [
						p: find prefix "."
						copy/part prefix p
					]
				]
			]
			distro-name
		]
		
		preboled-path:       to-file rejoin [ basis  "-preboled.r" ]
		output-exe-path:     to-file rejoin [ basis  ".exe" ]


		if dest-path [
			preboled-path:    join dest-path preboled-path
			output-exe-path:  join dest-path output-exe-path
		]
		
		
		preboled-path:    distro-path preboled-path
		output-exe-path:  distro-path output-exe-path
		v?? basis

		;v?? encap-path
		;v?? encap-exe
		;v?? encap-includes
		;v?? encapped-script-file
		
		v?? preboled-path
		v?? output-exe-path
		
		
		;ask "go!? ..."
		
		;---
		; we manually pre-process the code.
		;
		; when its done in the same pass as the encap, there are bugs in the resulting apps related to object binding and #include files.
		; not sure why.
		
		v?? source-file
		source-code: read source-file
		
		vprint ["Preprocessing :" mold/all source-file ]
		vprint ["file size :    " length? source-code " bytes" ]
		
		;vprint type? source-file
		;help source-file
		
		
		;-----------------
		; we now process-source() in a separate task because on large inputs, it buts the ram size!!
		;-----------------
		;   process-source/keep source-file
		;   write preboled-path mold/only result
		;   vprint ["result size: " length? mold/only result ]
		;   vprint ["saving as :  " preboled-path]
		;---
		execute rejoin [
			to-local-file pre-rebol-script
			" "
			to-local-file source-file
			" "
			to-local-file preboled-path
		]
		
		
		
		pause?: either pause [" -p " ][""] 

		;cmd: rejoin [ "" to-local-file encap-exe " -p -t " to-local-file distro-path encapped-script-file " -o " to-local-file distro-path encapped-exe-file  " " to-local-file distro-path source-file ] 
		cmd: rejoin [ "" to-local-file encap-exe pause? " -o " to-local-file output-exe-path  " " to-local-file preboled-path ]
		v?? cmd
		out: ""
		test: call/shell/console/error/info cmd out
		v?? out
		
;       cmd: rejoin [ "" to-local-file encap-exe " -p -t " to-local-file distro-path to-file rejoin ["direct-" encapped-script-file] " -o " to-local-file distro-path to-file rejoin ["direct-" encapped-exe-file ] " " to-local-file distro-path source-file ] 
;       ?? cmd
;       out: ""
;       test: call/shell/console/error/info cmd out
;       ?? out
;
;       probe test


		; reset path to the path on entry.
		change-dir here


		;------
		; GC cleanup
		result: cmd: out: pause?: source-code: source-file: preboled-path: output-exe-path: none

		vout



	]
	
	
	;--------------------------
	;-     frame-script()
	;--------------------------
	; purpose:  given a rebol script skip the header and surround the whole script in a do block.
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	frame-script: funcl [
		script [ string! ]
	][
		vin "slap/frame-script()"
		vprint ["MEM 1: " (stats / 1'000'000) "MB"]
		
		script: extract-script script
		vprint length? script
		vprint ["MEM 2: " (stats / 1'000'000) "MB"]
		header: copy/part head script script
		
		vprint ["MEM 3: " (stats / 1'000'000) "MB"]
		script: compress script
		vprint length? script
		
		vprint ["MEM 3.5: " (stats / 1'000'000) "MB"]
		recycle/off
		recycle/on
		
		vprint ["MEM 4: " (stats / 1'000'000) "MB"]
		vprint length? script
		vprint length? header 
		
		vprint ["MEM 5: " (stats / 1'000'000) "MB"]
		append header "^/do as-string decompress "
		vprint length? header


		vprint ["MEM 6: " (stats / 1'000'000) "MB"]
		append header mold script 
		vprint length? header
		

		vprint ["MEM 7: " (stats / 1'000'000) "MB"]
		clear script
		script: none
		
		recycle/off
		recycle/on
		
		
		vprint ["MEM 8: " (stats / 1'000'000) "MB"]
		vout
		first reduce [header header: none ]
	]
		
		
	;--------------------------------------------------------------------------------------------------
	;-  
	;- DISTRO FUNCTIONS
	;
	;--------------------------------------------------------------------------------------------------
	
	
	;--------------------------
	;-     --distro-root()
	;--------------------------
	; purpose:  an accessor which returns the current distro-dir value
	;
	; returns:  distro-dir
	;
	; notes:    since we cannot effectively expose literals, this replaces the use of distro-dir in slap files.
	;
	;           (DEPRECATED, useless)
	;           
	;--------------------------
	--distro-root: func [
	][
		distro-dir
	]
	


	;--------------------------
	;-     distro-path()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	distro-path: func [
		path [file!]
	][
		vin "slap/distro-path()"
		unless absolute-path? path [
			path: clean-path join distro-dir path
		]
		vout
		
		path
	]
	
	
	
	;--------------------------
	;-     get-last-distro()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	get-last-distro: funcl [
		/using root-path distro-spec [file!]
	][
		vin "slap/get-last-distro()"
		
		vout
	]
	
	

	
	;--------------------------
	;-     setup-distro()
	;--------------------------
	; purpose:  
	;
	; inputs:  
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	setup-distro: func [
		name [word!] "We use a word to force a clean disk name.  Please don't use weird characters."
		/spec file-spec [block!] "a spec that will be reduced. note that <RELEASE> will be replaced by a padded, auto-incrementing release number."
		/release r "overide the release number, forces a prompt if this replaces an existing release"
		/source src "The source directory of this distribution."
		/root dest "The distributions root directory to which file-spec is added."
		/local confirm?
	][
		vin "slap/setup-distro()"
		
		;-----
		; overide distro specs
		distro-name: name
		distro-root-spec: any [ file-spec  distro-root-spec ]
		
		root-dir: dirize clean-path any [dest root-dir]
		source-dir: dirize clean-path any [src source-dir]
		
		
		unless exists? root-dir [ make-dir root-dir ]
		
		
		;-----
		; manage release number
		unless release [
			r: any [ 
				all [
					i: get-current-release-number 
					i + 1
				]
				1
			]
		]
		
		update-distro-label r
		distro-dir: dirize join root-dir distro-label
		distro-root: copy distro-dir
		
		;-----
		; make sure we don't overwrite a distro without user confirmation.      
		either exists? distro-dir [
			confirm? ask rejoin [ "^/--------------------------^/WARNING ! a Distribution with this path: " distro-dir "^/already exists!^/^/ continuing will ERASE and rebuild this Distribution. ^/^/ press ^"Y^" and Enter to confirm, otherwise this script will abort." ]
			either all [
				not empty? confirm?
				confirm/1 = "y"
			][
				cleanup %./ ; remember that path ops are distro-dir relative
			][
				quit    
			]
		][
			make-dir/deep distro-dir
		]

		v?? distro-dir

		vout
	]
	
	


	
	;--------------------------
	;-     update-distro-label()
	;--------------------------
	; purpose:  takes the distribution label setup and makes the internal version used by various tools.
	;
	; inputs:  
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	update-distro-label: func [
		release [integer! none!] "the release number, if any."
		/local rel spec
	][
		vin "slap/update-distro-label()"
		
		bind (spec: copy distro-root-spec ) self
		
		if all [
			release 
			rel: find spec <RELEASE> 
		][
			change rel zfill release release-number-padding
		]
		
		;-----
		; build the distro-dir path
		distro-label: rejoin spec
		
		vout
	]
	

	
	;-----------------
	;-     get-current-release-number()
	;-----------------
	get-current-release-number: func [
		;distro-name
		/override ospec [block!] "Replace spec with this one."
		/root oroot [file!] "Overide the path in which to find the distro."
		/local d-list file i rnum  path spec =rule=
	][
	
		spec: any [ ospec   copy distro-root-spec ]
		root: any [ oroot   root-dir ]
			
		either not release: find spec <RELEASE> [
			ask "^/--------------------------------^/WARNING: There is no explicit <RELEASE> tag to specify the distribution counter within your slap/distro-root-spec .^/Press enter to continue...^/"
		][
			;-----
			; by default, the first release is 001
			rnum: 1
			
			;----
			; setup the parse rule required to match the 
			=rule=: append copy [] rejoin copy/part spec release
			append =rule= [copy i some =digit= ]
			append =rule= copy next release
			append =rule= "/"
			
			;vprobe =digit=
			;vprobe =rule=
			
			current-version: 0
			
			;-----
			; get list of distributions already in our distributions folder
			if exists? root [
				d-list: read root
				;probe d-list
				
				foreach file d-list [
					;probe file
					file: to-string file
					if parse/all file =rule= [
						i: to-integer i
						;print ["release: " i]
						if i > current-version [
							current-version: i
							;rnum: i + 1
						]
					]
					;ask "."
				]
			]
			;v?? rnum
			;ask "!!!"
		]
		if current-version = 0 [
			current-version: 0
		]
		current-version
	]
	
		
	
		
	;--------------------------------------------------------------------------------------------------
	;-  
	;- UTILITY FUNCTIONS
	;
	;--------------------------------------------------------------------------------------------------
	
	
	
	
	
	;--------------------------
	;-     set?()
	;--------------------------
	; purpose:  verifies if a word exists and evaluates to #[true]
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	set?: func [
		flag [any-type!]
	][
		all [
			value? get/any 'flag
			#[true] = get/any flag
		]
	]
	
	
	
	;--------------------------
	;-     distro-stats()
	;--------------------------
	; purpose:  
	;
	; inputs:  
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	distro-stats: func [
		
	][
		vin "slap/distro-stats()"
		v?? root-dir
		v?? distro-dir
		v?? source-dir
		v?? distro-name
		v?? distro-root-spec
		v?? distro-label
		vout
	]
	


	;--------------------
	;-     zfill()
	;--------------------
	zfill: func [
		"left fills the supplied string with zeros to amount size."
		string [string! integer!]
		length [integer!]
	][
		;vin/tags ["zfill()"] [zfill]
		if integer? string [
			string: to-string string
		]
		
		if (length? string) < length [
			head insert/dup string "0" (length - length? string)
		]
		;vout/tags [zfill]
		head string
	]
	
	

	
	;--------------------------
	;-     execute()
	;--------------------------
	; purpose:  execute a script, using the same interpreter path as the current
	;           like launch, but waits.
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	execute: funcl [
		cmd [string!]
	][
		vin "slap/execute()"
		cmd:  rejoin [
			to-local-file system/options/boot
			" -qs --script "
			cmd
		]
		vprint mold new-line/all parse cmd " " true
		call/wait/show cmd
		vout
	]
	



	;--------------------------------------------------------------------------------------------------
	;-  
	;- FILE PROCESSING FUNCTIONS
	;
	;--------------------------------------------------------------------------------------------------




	;--------------------------
	;-     fix()
	;--------------------------
	; purpose:  given a list of one or more files or directories, replace one or more strings of texts by some other text.
	;
	; inputs:   files and fixes to perform on those files
	;           fixes are specified as pairs of strings, one to find, the other to replace it with.
	;
	; returns:  number of files successfully fixed
	;
	; notes:    -given folders are fixed recursively, which may take some time.
	;           -a file extension filter is applied on recursive fixes... preset this within fix-extensions: or use /only
	;           -providing anything else than a string for fixes raises an error.
	; tests:    
	;--------------------------
	fix: fix*: func [
		files [file! block!] ; distro-relative
		fixes [string! block!]
		/source "get the files in the source directory instead of the distro."
		/local fix file data changed? dir path abs-path file? fix-to fixed-count file-list
	][
		vin [{fix()}]
		v?? files
		
		files: compose [(files)]
		fixes: new-line/skip compose [(fixes)]  true 2
		
		either source [
			dir: source-dir
		][
			dir: distro-dir
		]
		
		fixed-count: 0
		
		foreach path files [
		
			;----
			; verify the input
			either absolute-path? path [
				abs-path: path      
			][
				abs-path: join dirize dir path
			]
			
			unless exists? abs-path [
				print [ "fix() ERROR!! : file doesn't exist: " abs-path ]
				halt
			]
			
			if (file?: not is-dir? abs-path) <> (not dir? abs-path) [
				print [ "fix() ERROR!! : specified source path does not match its type on disk." ]
				print [ "spec is a        : " pick [ "file" "directory"] file? "  (" mold path ")" ]
				print [ "Path on disk is a: " pick ["file" "directory" ] not file? ]
				halt
			]
		
				
			either file? [
				;----
				; single file fix
				data: read abs-path
				
				;vprobe data
				
				changed?: false
				foreach [ fix fix-to ] fixes [
					;vprobe fix
					;vprobe fix-to
					unless changed? [
						if find data fix [
							changed?: true
						]
					]               
					replace/all data fix fix-to
				]
				;vprobe data
				either changed? [
					write abs-path data
					fixed-count: fixed-count + 1
					vprint ["Fixed:  " abs-path]
				][
					vprint ["ignred: " path]
				]
			][
				;----
				; directory tree fix (recursive)
				file-list: dir-tree/absolute abs-path
				
				vprobe file-list

				foreach path file-list [
					if is-dir? path [
						vprint ["fixing path: " path]
						fix* path fixes
					]
				]
				
			]
		]
		
;       vprint "----------------->"
;       vprint copy/part data 3000
;       vprint "<-----------------"
;       vout
;       v?? file

		file-list: changed?: files: fixes: file-list: data: fix: fix-to: abs-path: dir: none

		vout
		
		fixed-count
	]



	
	;--------------------------
	;-     extract-script()
	;--------------------------
	; purpose:  given a text file, returns the text after the header.
	;
	; inputs:   
	;
	; returns:  the script or none.
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	extract-script: funcl [
		data
	][
		vin "slap/extract-script()"
		;---
		; skip the first rebol word we find.
		until [
			blk: load/next data
			
			;v?? blk
			
			item: pick blk 1
			data: pick blk 2
		
			any [
				none? blk
				empty? data
				none? data
				tail? data
				item = 'rebol
			]
		]
		
		vprint type? data
		
		;---
		; skip the block after it
		if all [
			data
			string? data
			not empty? data
			not empty? blk: load/next data
		][
			if block? pick blk 1 [
				data: pick blk 2
			]
		]
		
		;---
		; make sure data is a script or none
		data: all [
			string? data
			not empty? data
			data
		]
		
		
			
		vout
		first reduce [ data   data: blk: item: none ]
	]
	
	
	

	


	;--------------------------
	;-     preprocess()
	;--------------------------
	; purpose:  a string-based preprocessor which doesn't obey the normal rules of REBOL syntax allowing you to
	;           be much more precise in your builds.
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	preprocess: funcl [
		origin [string! binary! file!]
		/keep-header "when a rebol source is given, skip the header.  Otherwise, we don't assume its a script.   note this option is not recursive."
		/options opt-blk [block! none!] "a block of options which can be easily cascaded and mutilated in recursive processing." 
	][
		vin "slap/preprocess()"
		;destination:  none
		
		if file? origin [
			v?? origin
			origin: distro-path origin
			
			file: file-part origin 
			file: rejoin [%pre-processed- file]
			
			v?? file
			v?? origin
			
			
			destination: substitute-file copy origin file
			
			v?? destination
			
			origin: read origin
		]
		
		vprobe type? origin
		
		;--
		; we skip rebol headers by default
		if all [
			;---
			; this IS a rebol script
			keep-header
			not origin: extract-script origin
		][
			to-error "Unable to skip header, not a rebol script."
		]
		
		i: 0
		
		parse/all origin [
			any [
				;------
				;-        #INCLUDE
				;--
				; the basic include just does file substitution.
				; it doesn't detect circular refs, so be careful.
				;
				; #INCLUDE IS recursive
				[
					op-start: "<#insert" opt [
						any [
							"/string"  ()   ; add outer brackets to insert as string.
							"/only"    ()   ; don't recursively preprocess data, really just insert file here.
							"/block"   ()   ; add output block brackets to essentially turn into a block of code (must be loadable data)
							"/binary"  ()   ; convert data into a binary, if possible, or generate an error.
							"/mold"    ()   ; load and mold/all the code.  preserving some types.
						]
					]
					
					some =whitespace= 
					copy op to "#>" 
					skip skip
					op-end:
					(
						;---
						; load the data
						op: load op
						
						;---
						; react based on type.
						switch/default type?/word op [
							file! [
								;---
								; optimise path
								;
								path: clean-path op
	
								unless exists? path [
									vprint [ to-local-file clean-path path " Doesn't exist" ]
									to-error "file access error"
								]
								data: read path
								
								;---
								; store path
								cwd: what-dir
								
								;---
								; restore our working path
								change-dir dir-part path
								
								;---
								; using a recursive call to preprocess within parse, we are able to effectively cause 
								; stack use, since the values are all contextualised to the function context by funcl.
								data: preprocess/options data opt-blk
								
								;---
								; restore our working path
								change-dir cwd
								
								;---
								; do the file replacement.
								change/part op-start data op-end
								
								there: skip op-start  (length? data)
							]
						][
							; nothing meaningful, just continue
							
							there: :op-start
						]
					) 
					:there 
				]
				| skip (i: i + 1   if i > 100'000 [prin "." i: 0])
			]
		]
		
		v?? destination
		
		if destination [
			write destination origin
		]
		
		
		data: destination: op-start: op-end: op: path: data: cwd: there: none
		
		
		vout
		first reduce [origin  origin: none]
	]
	
		


	;--------------------------
	;-     archive()
	;--------------------------
	; purpose:  given a root-path, it will compress all files inside and consolidate them into one block of binaries.
	;
	; inputs:   
	;
	; returns:  a context which has all the meta and binary data.
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	archive: funcl [
		root [file!]
	][
		vin "slap/archive()"
		files: sort dir-tree root
		
		blk: []
		
		ctx: context [
			files: blk
		]
		
		foreach file files [
			vprint ["packing: " join root file]
			append blk file
			either is-dir? file [
				append blk none
			][
				append blk compress read/binary join root file
			]
		]
		
		vprobe files
		vout
		first reduce [ blk    blk: file: ctx: files: root: none ]
		
	]
	
	
	
	
	;--------------------------
	;-     blow()
	;--------------------------
	; purpose:  given an archive object, blows it back to disk.
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	blow: funcl [
		archive [block!]
		install-dir [file!]
		/hook callback [function!]
	][
		vin "slap/blow()"
		l: (length? archive) / 2 ; length
		
		foreach [file data] archive [
			wait 0 ; when its within a GUI... allows it to react/refresh
			i: i + 1
			path: clean-path join install-dir file
			
			if hook [
				callback i l install-dir file data
			]
			vprint to-local-file path
			v?? i
			
			either data [
				data: decompress data
				write/binary path data
			][
				make-dir/deep path
			]
		]
		vout
	]
	

	
	
	;-----------------------------------------------------------------------------------------------------------
	;
	;- FILE OPERATION FUNCTIONS 
	;
	;-----------------------------------------------------------------------------------------------------------
	

	

	
	;--------------------------
	;-     fetch()
	;--------------------------
	; purpose:  take a file from the distro (or any absolute path) and dump in the source 
	;
	; inputs:   file path
	;
	; returns:  computed destination path
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	fetch: func [
		src [file!] "Source file or folder to copy within the distribution.  Paths must respect their disk types (file or directory), any mismatch generates an error."
		/as as-file [file!]  "Alternate destination/name.  must match the src filetype (file or directory)."
		/to to-dir [file!] "Dump to a different path within the distro. MUST be a directory path.  You can use absolute paths."
		;/fetch
		/local dest
	][
		vin "slap/fetch()"
		dest: apply :dump [src as as-file to to-dir  #[true]]
		vout
		dest
	]
	
	
		
	
	;--------------------------
	;-     dump()
	;--------------------------
	; purpose:  
	;
	; inputs:  
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	dump: func [
		src [file! block! word!] "Source file or folder to copy within the distribution.  Paths must respect their disk types (file or directory), any mismatch generates an error."
		/copy "The source and destination are both within destination."
		/as as-file [file!]  "Alternate destination/name.  must match the src filetype (file or directory)."
		/to to-dir [file!] "Dump to a different path within the distro. MUST be a directory path.  You can use absolute paths."
		/fetch "inverses the meaning of the distro and source directories"
		/local src-type file? dest abs-src  lcl-distro-dir lcl-source-dir file rblk
	][
		vin "slap/dump()"
		v?? src
		v?? as
		v?? as-file
		v?? to
		v?? to-dir
		v?? fetch
		vprint "-----------------------"
		
		
		;---------------------------------
		; manage special src types
		;
		case [
			block? src [
				rblk: copy* []
				foreach file src [
					append rblk apply :dump [  file  copy  as  as-file  to  to-dir fetch  ]
				]
				return rblk
			]
			
			;------------------
			; script name (usefull for list of slim libraries)
			any [word? src   lit-word? src ] [
				src: to-file rejoin [ "" src ".r" ]
			]
		]
		
		either fetch [
			lcl-distro-dir: source-dir
			lcl-source-dir: distro-dir
		][
			lcl-distro-dir: distro-dir
			lcl-source-dir: source-dir
		]
		
		if copy [ lcl-source-dir: lcl-distro-dir ]
		;----
		; we cannot ask for /AS and /TO in the same call.
		if all [
			as
			to
		][
			print ["dump() ERROR: /AS and /TO are mutually exclusive, you can not use dump() with both."]
			halt
		]
		
		;----
		; verify the input
		either absolute-path? src [
			abs-src: src
		][
			abs-src: join dirize lcl-source-dir src
		]
		if (file?: not is-dir? abs-src) <> (not dir? abs-src) [
			print [ "Dump() ERROR!! : specified source path does not match its type on disk." ]
			print [ "spec is a        : " pick [ "file" "directory"] file? "  (" mold abs-src ")" ]
			print [ "Path on disk is a: " pick ["file" "directory" ] not file? ]
			halt
		]
		
		;----
		; src and as-file must be of the same type
		if all [
			as-file
			file? <> (not is-dir? as-file)
		][
			print ["dump() ERROR: /AS as-file must match the path type (file or directory) given in src argument."]
			halt
		]
		
		;----
		; to-dir must be a dir
		if all [
			to
			not is-dir? to-dir
		][
			print ["dump() ERROR: /TO to-file must be a directory path."]
			halt
		]
		
		
		;----
		; absolute src dirs REQUIRE a /TO or /AS path
		if all [
			absolute-path? src
			not any [to as]
		][
			print [ "dump() ERROR: Absolute source paths, require you provide one of /TO or /AS refinements.^/Path given: " src ]
			halt
		]
		
		
		;----
		; generate the destination path
		dest: case [
			as [
				; /AS is a direct specification for the output path in both file and dir paths.
				either file? [
					either dir-part as-file [
						as-file
					][
						;--
						; as-file with no path simply renames the file within the same dir depth
						; as in the lcl-source-dir
						; use %./  to force the file to be put within the root of the distro.
						to-file rejoin [
							any [ dir-part src ""]
							file-part as-file
						]
					]
				][
					as-file
				]
			]
			to [
				; /TO is an alternative directory, in which to place the content of a file.
				;  keeping the top level part of the source path when its a directory.
				either file? [
					join to-dir file-part src
				][
					; we cover any src path, even the root of the lcl-source-dir!
					rejoin [ to-dir   any [second split-path src "" ] ]
				]
			]
			true [src]
		]
		
		v?? fetch
		v?? src
		v?? dest
		
		dest: any [
			all [file? fetch  (dump-file/fetch src dest) ]
			all [file?  (dump-file src dest) ]
			all [fetch (dump-dir/fetch src dest)]
			dump-dir src dest
		]
		
		
		
		
		
		vout
		dest
	]
	
	
	
	;--------------------------
	;-     dump-file()
	;--------------------------
	; purpose:  transfers a FILE from the source to distro (or vice-versa if /fetch is used)
	;
	; inputs:   two paths, absolute or relative
	;
	; returns:  the computed destination path
	;
	; notes:    DOES NO ERROR CHECKING.  DO NOT USE THIS MANUALLY.
	;
	; tests:    
	;--------------------------
	dump-file: func [
		src [file!]
		dest [file! none!]
		/fetch
		/local lcl-distro-dir lcl-source-dir a
	][
		vin "slap/dump-file()"
		v?? fetch
		either fetch [
			lcl-distro-dir: source-dir
			lcl-source-dir: distro-dir
		][
			lcl-distro-dir: distro-dir
			lcl-source-dir: source-dir
		]


		unless absolute-path? src [
			src: join lcl-source-dir src
		]
		
		unless absolute-path? dest [
			dest: join lcl-distro-dir dest
		]
		
		src:  clean-path src
		dest: clean-path dest

		vprint rejoin [
			"---" newline
			"Dumping file to "  either fetch ["SLAP SOURCE:"]["DISTRO:"]  newline 
			"  FROM: " src newline 
			"  TO:   " dest  newline 
		]

			
		unless exists? dir-part dest [make-dir/deep dir-part dest]

		write/binary dest a: read/binary src

		clear a
		a: none

		vout
		dest
	]
	
	
	
	
	;--------------------------
	;-     dump-dir()
	;--------------------------
	; purpose:  transfers a DIRECTORY tree from the source to distro (or vice-versa if /fetch is used)
	;
	; inputs:   two paths, absolute or relative
	;
	; returns:  the computed destination path
	;
	; notes:    DOES NO ERROR CHECKING.  DO NOT USE THIS MANUALLY.
	;
	; tests:    
	;--------------------------
	dump-dir: func [
		src [file!]
		dest [file! none!]
		/fetch
		/local lcl-distro-dir lcl-source-dir
	][
		vin "slap/dump-dir()"
		
		either fetch [
			lcl-distro-dir: source-dir
			lcl-source-dir: distro-dir
		][
			lcl-distro-dir: distro-dir
			lcl-source-dir: source-dir
		]

		unless absolute-path? src [
			src: join lcl-source-dir src
		]
		
		unless absolute-path? dest [
			dest: join lcl-distro-dir dest
		]
		

		src:  clean-path src
		dest: clean-path dest

		vprint rejoin [
			"---" newline
			"Dumping DIRECTORY to distro:"  newline 
			"  FROM: " src newline 
			"  TO:   " dest  newline 
		]
		
		unless exists?  dest [make-dir/deep dest]
		
		copy-dir src dest
		vout
		
		dest
	]
	
	
	
	;--------------------------
	;-     rename*()
	;--------------------------
	; purpose:  rename a file or directory within the distro
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	rename*: funcl [
		from
		to
	][
		vin "slap/rename*()"
		
		from: distro-path from
		
		
		v?? from
		v?? to
		
		rename  from to
		
		vout
	]
	
	
	

	
	;-----------------
	;-     cleanup()
	;
	; removes a file or a directory from the distribution
	;
	; usefull when we copy a whole directory but want to remove some files out of it.
	;-----------------
	cleanup: func [
		paths [file! block!]
		/source "cleans the source directory, not the distro"
		/local file?
	][
		vin [{cleanup()}]
		paths: compose [(paths)]
		
		foreach path paths [
			unless absolute-path? path [
				either source [
					path: join source-dir path
				][
					path: join distro-dir path
				]
			]
			
			;----
			; verify the input
			if (file?: not is-dir? path) <> (not dir? path) [
				print [ "Dump() ERROR!! : specified source path does not match its type on disk." ]
				print [ "spec is a        : " pick [ "file" "directory"] file? "  (" mold path ")" ]
				print [ "Path on disk is a: " pick ["file" "directory" ] not file? ]
				halt
			]
			
			;v?? path
			;print is-dir? path
			;print not dir? path
			;print exists? path
			;ask "??"
				
			either exists? path [
				v?? path
				either dir? path [
					delete-dir path
				][
					delete path
				]
			][
				vprint ["file doesn't exist: " path]
			]
		]
		
		vout
	]





	;-----------------
	;-     create-dir()
	;-----------------
	create-dir: func [
		path [file!]
	][
		make-dir/deep clean-path join distro-dir dirize path
	]
	


	;-----------------
	;-     absolute-path?()
	;-----------------
	absolute-path?: func [
		path [file!]
	][
		#"/" = first path
	]
	
	
	
	
	;-------------------
	;-     is-dir?()
	;-----
	is-dir?: func [path [string! file!]][
		path: to-string path
		replace/all path "\" "/"
		
		all [
			path: find/last/tail path "/"
			tail? path
		]
	]
	
	

	;-----------------
	;-     dir-tree()
	;-----------------
	dir-tree: func [
		path [file!]
		/root rootpath [file! none!]
		/absolute "returns absolute paths"
		/local list item data subpath dirpath rval
	][
		rval: copy []
		either root [
			unless exists? rootpath [
				to-error rejoin [ "compiler/dir-tree()" path " does not exist" ]
			]
		][
			either is-dir? path [
				rootpath: path
				path: %./
			][
				to-error rejoin [ "compiler/dir-tree()" path " MUST be a directory." ]
			]
		]
		
		dirpath: clean-path append copy rootpath path
		
		either is-dir? dirpath [
			; list directory content
			list: read dirpath
			
			; append that path to the file list
			append rval path
			
			foreach item list [
				subpath: join path item
				
				; list content of this new path item (files are returned directly)
				either absolute [
					data: dir-tree/root/absolute subpath rootpath
				][
					data: dir-tree/root subpath rootpath
				]
				if (length? data) > 0 [
					append rval data
				]
			]
		][
			if absolute [
				path: clean-path join rootpath path
			]
			; when the path is a file, just return it, it will be compiled with the rest.
			rval: path
		]
		
		if block? rval [
			rval: new-line/all  head sort rval true
		]
		
		rval
	]

	
	
	;-----------------
	;-     copy-dir()
	;-----------------
	copy-dir: func [
		source  [file!]
		dest [file!]
		/local list
	][
		vin [{copy-dir()}]
		either is-dir? dest [
			foreach file dir-tree source [
				either is-dir? file [
					make-dir/deep join dest file
				][
					write/binary join dest file read/binary vprobe join source file
				]
			]
		][
			to-error "copy-dir() dest is not a dirpath"
		]
		vout
	]
	
	
	
	;-----------------
	;-     file-part()
	;-----------------
	file-part: func [
		path [file!]
		/local file
	][
		if file: any [
			find/tail/last path "/"
			path
		][
			file: unless empty? file [
				copy file
			]
		]
		file
	]
	
	
	;-----------------
	;-     dir-part()
	;-----------------
	dir-part: func [
		path [file!]
		/local file dir
	][
		if file: find/tail/last path "/" [
			dir: copy/part path file
		]
		dir
	]
	
	
	
	;--------------------------
	;-     ext-part()
	;--------------------------
	; purpose:  returns the extension part of a file path
	;
	; inputs:   a file path
	;
	; returns:  -the extension of the file, or none, if its a directory (even if it contains a "." in the path)
	;           -we silently ignore none inputs by returning none
	;
	; notes:    -we rely only on the file path given, not its actual disk type to verify if the input is indeed a directory.
	;
	; tests:    
	;--------------------------
	ext-part: func [
		file [file! none!]
		/local ext
	][
		vin "slap/ext-part()"
		ext: none ; prevent reuse of a previous call to ext-part() static pointer to ext
		
		if file [
			if is-dir? file [
				print ["ext-part() ERROR: must provide a FILE path, not a directory path (given: " file ")."]
			]

			if ext: find/last/tail file "."  [
				ext: copy ext
			]
		]

		vout

		ext

	]
	
	
	
	
	
	;- UNREVISED
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;
	;                                                                   unverified old code
	;
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	;-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	
	
	
	
	;-----------------
	;-     slim-link()
	;
	; takes a file in the distro-dir and slim-links it.
	;
	; you must have loaded slim prior to calling this function.
	;
	; note that if you only specify an input-path, this function
	; will overwrite it with its linked version.
	;-----------------
	slim-link: func [
		input-path [file!]
		/to output-path [file!]
		/distro "relative file paths are relative to distro instead of source"
		/local input-dir input-file output-file output-dir data success?
	][
		vin [{slim-link()}]
	
		; must specify an input
		if input-file: file-part input-path [
		
			input-dir: any [dir-part input-path copy %./]
			either to [ 
				; try to use whatever is given within output path, use input 
				; as the default otherwise.
				output-dir:  any [dir-part output-path    input-dir]
				output-file: any [file-part output-path   input-file]
			][
				; use the input-path to build an output path automatically
				output-dir: input-dir
				output-file: join %linked- input-file
			]
			
			output-path: join output-dir output-file
			
			if distro [
				unless absolute-path? input-path [
					input-path: join distro-dir input-path
				]
				unless absolute-path? output-path [
					output-path: join distro-dir output-path
				]
			]
			
			
		
			; get slim-link module.
			linker: slim/open 'slim-link none
	
			v?? input-path
			v?? output-path
	
			; link the file
			data: linker/link input-path
			
			; save it out.
			write output-path data
			
			; just a little wait to be sure the disk has finished before sending
			; new call commands. (yes I've had problems with this on XP)
			wait 0.1
			
			success?: true
		]
	
		vout
		
		success?
	]
	
	
	
	
	
	
	
	
	
	
	
	;-----------------
	;-     --fetch()
	; the opposite of dump, will take files or dir FROM distro (by default) and bring them into source dir
	;-----------------
	--fetch: func [
		src [file!]
		/to dest [file! ] "can only be a directory"
		/as as-file [file!]  "can only be a file (any dir is ignored)"
		/local destination-dir destination-file from-dir from-file
	][
		vin "slap/fetch()"
		
		; uniformitize and verify the input
		if to [
			unless is-dir? dest [
				to-error rejoin ["/TO must be a folder, not a file path:" dest]
			]
		]
		
		if as-file [
			as-file: file-part as-file
		]
		
		
		; make sure any directory source is properly identified later on.
		if dir? src [
			src: dirize src
		]
		
		from-file: file-part src
		from-dir: copy any [dir-part src distro-dir]
		
		; set the default destination-dir
		destination-dir: copy %./
		
		either to [
			destination-dir: copy dest
		][
			; add src to out put path if a dir and not absolute
			if all [
				is-dir? src
				not absolute-path? src 
			][
				append destination-dir src
			]
		]
		
		; contextualize the input directory within distro?
		unless absolute-path? from-dir [
			from-dir: join distro-dir from-dir
		]
		
		; make source dir an absolute path.
		from-dir: clean-path from-dir
		
		; select between two fetch modes.
		either is-dir? src [
			; fast OS folder copying call
			copy-dir from-dir destination-dir
		][
			; REBOL simple file copying...
			
			; there MUST be an input file to copy
			unless from-file [
				to-error rejoin ["no filename to dump:" src]
			]
	
			; might evolve later.
			destination-file: any [ as-file copy from-file]
			
	
			vprint rejoin [
				"---" newline
				"Dumping file to distro:"  newline 
				"  FROM: " join from-dir from-file  newline 
				"  TO:   " join destination-dir destination-file  newline 
			] 
			write/binary join destination-dir destination-file read/binary join from-dir from-file
		]
	
		vout
	]
		
		
	
	;--------------------------
	;-     pack-rip()
	;--------------------------
	; purpose:  
	;
	; inputs:   
	;
	; returns:  
	;
	; notes:    
	;
	; tests:    
	;--------------------------
	pack-rip: funcl [
	][
		vin "slap/pack-rip()"
		source-path [file!]
		output-root [file!] "Use this as the root when storing files within the archive."
		vout
	]
	
	
	
	;-----------------
	;-     rip()
	;
	; takes the rip script from rebol.org and reformats it for this build system
	;-----------------
	rip: func [
		/save-to output-path [file!]
		/force "If files exist, don't ask for any confirmation"
		/local output-file output-dir archive file-list file files header from-size to-size from-total path
	][
		vin [{rip()}]
	
	;   path: to-file ask {
	;   Enter the relative directory path.
	;   Press RETURN key for current directory,
	;   or type a path in the form: dir/dir/dir
	;   
	;   Directory? }
		
		;if empty? path [path: %./]
		;if (last path) <> #"/" [append path #"/"]
		source-path: dirize source-path
		
		
		v?? source-path
		v?? output-path
		v?? output-root
		;ask "!"
		
		if not exists? source-path [vprint [path "does not exist"] halt]
		
		file-list: copy []
		archive: make binary! 32000
		from-total: 0
		vprint "Archiving:"
		foreach file files: read source-path [
			either dir? source-path/:file [
				append file-list reduce [file 'DIR ]
				foreach newfile read source-path/:file [append files file/:newfile]
			][
				data: read/binary source-path/:file
				from-size: length? data
				from-total: from-total + from-size
				data: compress data
				to-size: length? data
				vprint [file "         " from-size " -> " to-size]
				append archive data
				append file-list reduce [file length? data]
			]
		]
		
		vprint [newline "Total size:" length? archive " (From: " from-total ",  " 100 * (1 - (round/to ( ( length? archive) / from-total ) 0.001)) "% reduction )   Checksum:" checksum archive newline]
		
		;output-file: to-file ask "Output archive file name? "
		;if empty? output-file [output-file: %archive.rip]
		
		if save-to [
			unless output-file: file-part output-path [
				output-file: %archive.rip
			]
			output-dir: any [dir-part output-path %./]
			
			if not find output-file "." [append output-file ".rip"]
			
			; uniformitize the output path back into a single path, based on any path fixing we did above
			output-path: join output-dir output-file
			
			if all [
				exists? output-path 
				not force
				not confirm reform ["Overwrite file" output-path "? "]
			][
				print "stopped" halt
			]
		]
		;set [ignore file] split-path output-path
		;file: to-file file  ; for 2.2 compat
		;file: output-file
		
		header: mold compose/deep/only [
			REBOL [
				Title: "REBOL Self-extracting Binary Archive (RIP)"
				Date: (now/date)
				File: (output-file)
				Note: (reform [{To extract, type REBOL} file {or run REBOL and type: do} file])
			]
			file: (output-file)
			size: (length? archive)
			path: (output-root)
			verbose: not all [system/script/args system/script/args = 'quiet]
			files: (new-line/skip file-list true 2)
			check: (checksum archive)
			if not exists? path [make-dir/deep path]
			archive: read/binary file
			archive: next find/case/tail archive to-binary join "!DATA" ":"
			
			;if check <> checksum archive [print ["Checksum failed" check checksum archive] halt]
			
			foreach [file len] files [
				;if verbose [print [tab file]]
				either len = 'DIR [
					if not exists? path/:file [make-dir/deep path/:file]
				][
					?? len
					data: copy/part archive len
					;write/binary %data.rip data
					;probe data
					;ask "?"
					data: decompress data
					;ask "!"
					archive: skip archive len
					either any [
						not exists? path/:file
						confirm reform [file "already exists - overwrite? "]
					][
					write/binary path/:file data][print "skipped"]
				]
			]
			none
		]
		
		insert archive reduce [header newline "!DATA:" newline]
		
		if save-to [
			v?? output-path
			write/binary output-path archive
		]
		
		vout
		
		first reduce [ archive archive: none ]
	]
	
]

;------------------------------------
; We are done testing this library.
;------------------------------------
;
; test-exit-slim
;
;------------------------------------

